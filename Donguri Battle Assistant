// ==UserScript==
// @name         Donguri Battle Assistant
// @namespace    https://donguri.5ch.net/
// @version      0.0.8.5
// @description  5ちゃんねるのどんぐりシステムから派生したゲームの操作性を改善するためのユーザースクリプト
// @author       福呼び草
// @match        https://donguri.5ch.net/teambattle?m=*
// @run-at       document-start
// @grant        GM_addStyle
// ==/UserScript==

(function() {
  'use strict';

  // 対象モード（hc / l / rb）以外では動かさない
  const mode = new URL(location.href).searchParams.get('m');
  if (!['hc', 'l', 'rb'].includes(mode)) return;

  // ============================================================
  // ▽ここから▽ CSS 定義ゾーン（集中管理）
  // ============================================================
  const CSS = `
    :root{
      --dba-fn-bg: #f0f0f0;
      --dba-fn-fg: #111;
      --dba-fn-border: #000;
      --dba-fn-shadow: rgba(0,0,0,0.15);
      --dba-fn-height: 50px; /* ファンクションセクションの高さ */
      --dba-layer-text-opacity: 1; /* 0.0 - 1.0（レイヤー上の文字濃度） */
    }

    /* ファンクションセクション本体 */
    #dba-function-section{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--dba-fn-height);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      background: var(--dba-fn-bg);
      color: var(--dba-fn-fg);
      border-bottom: 1px solid var(--dba-fn-border);
      box-shadow: 0 2px 8px var(--dba-fn-shadow);
      z-index: 999999;
    }

    /* 既存ページを隠さないため、上に余白を確保 */
    html.dba-has-fnbar body{
      padding-top: calc(var(--dba-fn-height) + 4px) !important;
    }

    /* ===== バトルマップ透明レイヤー（将来の拡張用土台） ===== */
    #dba-battlemap-layer{
      position: fixed;
      left: 0;
      top: 0;
      width: 0;
      height: 0;
      z-index: 999990; /* fnbar(999999)より下、マップより上 */
      pointer-events: none; /* 現段階ではページ既存操作を妨げない */
      background: transparent;
    }
    #dba-battlemap-layer-grid{
      width: 100%;
      height: 100%;
      display: grid;
      background: transparent;
      box-sizing: border-box;
    }
    .dba-layer-cell{
      position: relative;
      background: transparent;
      box-sizing: border-box;
    }
    .dba-layer-cell__content{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      font-size: 0.9rem; /* レイヤー上のセルのフォントサイズ */
      font-weight: 700;
      line-height: 0.95rem;
      opacity: var(--dba-layer-text-opacity);
      user-select: none;
      pointer-events: none;
      /* 左上寄せ + 折り返し + 下方向は隠す */
      padding: 2px 2px;
      box-sizing: border-box;
      overflow: hidden;           /* 下にあふれた分は非表示 */
      white-space: pre-wrap;      /* 改行を維持しつつ折り返し */
      overflow-wrap: anywhere;    /* 長い単語も折り返し */
      word-break: break-word;     /* 互換用 */
      text-align: left;
      text-shadow:
        0 0 2px rgba(255,255,255,0.95),
        0 0 6px rgba(255,255,255,0.75);
    }

    /* 汎用ボタン（機能系ボタン共通） */
    .dba-btn-fn{
      appearance: none;
      margin:4px;
      padding: 8px 4px;
      border: 2px solid #000;
      border-radius: 12px;
      background: #f08800;
      color: #fff;
      font-size: 1em;
      font-weight: 500;
      line-height: 1em;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
      transition: transform 0.05s ease, box-shadow 0.15s ease, background 0.15s ease;
    }
    .dba-btn-fn:hover{
      background: #0000e0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.16);
    }
    .dba-btn-fn:active{
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
    }
    .dba-btn-fn:focus{
      outline: 2px solid #ea0000;
      outline-offset: 2px;
    }
    /* ===== モーダル（標準） ===== */
    .dba-m-std{
      border: 4px solid #080;
      border-radius: 12px;
      padding: 0;
      margin: auto;
      width: min(560px, calc(100vw - 24px));
      max-height: min(80vh, calc(100vh - 24px));
      background: #f8f8f8;
      color: #111;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    }
    .dba-m-std::backdrop{
      background: rgba(0,0,0,0.55);
    }
    .dba-m-std .dba-modal__top{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid #000;
      background: #f0f0f0;
    }
    .dba-m-std .dba-modal__title{
      font-size: 1.25em;
      font-weight: 700;
      margin: 0;
      padding: 0;
    }
    .dba-m-std .dba-modal__mid{
      padding: 12px;
      overflow: auto;
      max-height: calc(min(80vh, calc(100vh - 24px)) - 110px);
    }
    .dba-m-std .dba-modal__bot{
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid #000;
      background: #f0f0f0;
    }

    /* ===== セル詳細モーダル（サイズ最適化） ===== */
    #dba-m-cell-detail.dba-m-std{
      width: min(760px, calc(100vw - 24px));
      max-height: min(88vh, calc(100vh - 24px));
    }
    #dba-m-cell-detail.dba-m-std .dba-modal__mid{
      /* 標準(80vh)の計算を、セル詳細(88vh)に合わせて上書き */
      max-height: calc(min(88vh, calc(100vh - 24px)) - 110px);
    }

    /* ===== 戦闘結果モーダル（サイズ最適化 + スクロール） ===== */
    #dba-m-battle-result.dba-m-std{
      width: min(820px, calc(100vw - 24px));
      /* 長い時はここで上限、短い時は content に合わせて自然に縮む */
      max-height: min(88vh, calc(100vh - 24px));
      /* スクロールは mid のみに限定（dialog全体にはスクロールを出さない） */
      overflow: hidden;
    }
    #dba-m-battle-result.dba-m-std .dba-modal__mid{
      /* 常にスクロール可能（短い時はスクロールは出ない） */
      overflow: auto;
      /* 上限は max-height で決まる。短文なら高さは自然に小さくなる */
      max-height: calc(min(88vh, calc(100vh - 24px)) - 110px);
      /* スクロールバーを見やすく（OS依存だが効く環境では効く） */
      scrollbar-gutter: stable both-edges;
    }
    /* 戦闘結果テキストをそのまま読みやすく表示 */
    .dba-battle-result-text{
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
      line-height: 1.25em;
      font-weight: 600;
      font-size: 0.98em;
      text-align: left; /* 戦闘結果は左寄せ */
    }

    /* ===== モーダル（アラート） ===== */
    #dba-m-alert.dba-m-alert{
      border: 4px solid #e00;
      border-radius: 12px;
      padding: 0;
      margin: auto;
      width: min(420px, calc(100vw - 24px));
      background: #f0f0cc;
      color: #000;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    }
    #dba-m-alert.dba-m-alert::backdrop{
      background: rgba(0,0,0,0.55);
    }
    #dba-m-alert .dba-alert__mid{
      padding: 14px 12px;
      font-size: 1.15em;
      font-weight: 700;
      line-height: 1.3em;
    }
    #dba-m-alert .dba-alert__bot{
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid #000;
      background: #f0f0e0;
    }

    /* ===== モーダル用ボタン（標準化） ===== */
    .dba-btn-ok,
    .dba-btn-apply,
    .dba-btn-close,
    .dba-btn-x{
      appearance: none;
      width: 4em;
      border: 2px solid #000;
      border-radius: 12px;
      margin: 4px 8px;
      padding: 8px auto;
      font-size: 1em;
      font-weight: 600;
      line-height: 1.1em;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
      transition: transform 0.05s ease, box-shadow 0.15s ease, filter 0.15s ease;
      background: #f00;
      color: #fff;
    }
    .dba-btn-ok:hover,
    .dba-btn-apply:hover,
    .dba-btn-close:hover,
    .dba-btn-x:hover{
      filter: brightness(0.97);
      box-shadow: 0 2px 6px rgba(0,0,0,0.16);
    }
    .dba-btn-ok:active,
    .dba-btn-apply:active,
    .dba-btn-close:active,
    .dba-btn-x:active{
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
    }
    .dba-btn-ok{ background:#2280e0; color:#fff; }
    .dba-btn-apply{ background:#33a033; color:#fff; }
    .dba-btn-close{ background:#e02222; color:#fff; }
    .dba-btn-x{
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 16px;
      background:#e02222;
      color:#fff;
      font-size: 1.4rem;
      line-height: 1.4rem;
    }

    /* 設定UI小物 */
    .dba-setting-row{
      display: grid;
      grid-template-columns: 1fr 120px;
      gap: 10px;
      align-items: center;
      padding: 8px 6px;
      border: 1px solid #00000022;
      border-radius: 10px;
      background: #fff;
      margin-bottom: 10px;
    }
    .dba-setting-row label{
      text-align: left;
      font-weight: 700;
    }
    .dba-setting-row input[type="number"]{
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border: 1px solid #00000055;
      border-radius: 10px;
      font-size: 1em;
    }
    .dba-setting-row input[type="range"]{
      width: 100%;
      box-sizing: border-box;
    }

    /* ===== 装備ロスター ===== */
    #dba-m-roster.dba-m-std{
      width: min(920px, calc(100vw - 24px));
      max-height: min(88vh, calc(100vh - 24px));
      overflow: hidden;
    }
    #dba-m-roster.dba-m-std .dba-modal__mid{
      max-height: calc(min(88vh, calc(100vh - 24px)) - 110px);
      overflow: auto;
    }
    .dba-roster-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .dba-roster-title{
      font-size: 1.15em;
      font-weight: 800;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .dba-roster-head-btns{
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    .dba-btn-mini{
      appearance: none;
      border: 2px solid #000;
      border-radius: 10px;
      padding: 6px 10px;
      margin: 0;
      font-size: 0.95em;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      background: #eee;
      color: #000;
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
    }
    .dba-btn-mini:hover{ filter: brightness(0.97); }
    .dba-btn-mini:active{ transform: translateY(1px); }
    .dba-btn-mini--danger{ background:#f3d0d0; }
    .dba-btn-mini--ok{ background:#cfe3ff; }

    .dba-roster-row2{
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
      margin: 12px 0;
    }
    .dba-roster-list{
      border: 1px solid #000;
      border-radius: 12px;
      background: #fff;
      padding: 8px;
      overflow: hidden;
    }
    .dba-roster-item{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #00000022;
      margin: 6px 0;
      cursor: pointer;
      user-select: none;
    }
    .dba-roster-item:hover{ background: #f7f7f7; }
    .dba-roster-item[data-selected="1"]{
      outline: 3px solid #ea0000;
      outline-offset: 0px;
      background: #fff2f2;
    }
    .dba-roster-item__name{
      font-weight: 800;
      text-align: left;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .dba-roster-item__meta{
      font-size: 0.9em;
      font-weight: 700;
      opacity: 0.9;
      white-space: nowrap;
    }

    /* ===== 装備プリセット追加モーダル ===== */
    #dba-m-roster-add.dba-m-std{
      width: min(760px, calc(100vw - 24px));
      max-height: min(88vh, calc(100vh - 24px));
      overflow: hidden;
    }
    #dba-m-roster-add.dba-m-std .dba-modal__mid{
      max-height: calc(min(88vh, calc(100vh - 24px)) - 110px);
      overflow: auto;
    }
    .dba-add-wrap{
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 10px;
      align-items: start;
    }
    .dba-add-left{
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }
    .dba-add-right{
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }
    .dba-add-sel{
      border: 1px solid #000;
      border-radius: 12px;
      background: #fff;
      padding: 8px 10px;
      min-height: 2.4em;
      font-weight: 700;
      text-align: left;
      overflow-wrap: anywhere;
    }
    .dba-add-name{
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border: 2px solid #000;
      border-radius: 12px;
      font-size: 1em;
      font-weight: 700;
    }
    .dba-add-bot{
      display: flex;
      gap: 12px;
      justify-content: flex-start;
      align-items: center;
      margin-top: 10px;
    }

    /* ===== アイテム選択（バッグ表） ===== */
    #dba-m-pick-item.dba-m-std{
      width: min(1100px, calc(100vw - 24px));
      max-height: min(90vh, calc(100vh - 24px));
      overflow: hidden;
    }
    #dba-m-pick-item.dba-m-std .dba-modal__mid{
      max-height: calc(min(90vh, calc(100vh - 24px)) - 110px);
      overflow: auto;
    }
    .dba-pick-hint{
      font-weight: 700;
      margin: 0 0 10px 0;
      text-align: left;
    }

    /* ===== アイテム選択：レアリティフィルタ ===== */
    .dba-pick-filterbar{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;
      margin: 0 0 10px 0;
      padding: 8px 10px;
      border: 1px solid #000;
      border-radius: 12px;
      background: #fff;
    }
    .dba-pick-filterbtn{
      appearance: none;
      border: 2px solid #000;
      border-radius: 10px;
      padding: 6px 10px;
      margin: 0;
      font-size: 0.95em;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      background: #eee;
      color: #000;
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
    }
    .dba-pick-filterbtn:hover{ filter: brightness(0.97); }
    .dba-pick-filterbtn:active{ transform: translateY(1px); }
    .dba-pick-filterbtn[data-active="1"]{
      outline: 3px solid #ea0000;
      outline-offset: 0px;
      background: #fff2f2;
    }
    .dba-pick-filterbtn--all{ background:#e8e8e8; }
    .dba-pick-filterbtn--n{ background:#ffffff; }
    .dba-pick-filterbtn--r{ background:#3fa435; color:#fff; }
    .dba-pick-filterbtn--sr{ background:#2175d9; color:#fff; }
    .dba-pick-filterbtn--ssr{ background:#a633d6; color:#fff; }
    .dba-pick-filterbtn--ur{ background:#f45d01; color:#fff; }

    /* ===== アイテム選択：MOD 0 フィルタ ===== */
    .dba-pick-filterchk{
      display: inline-flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-start;
      font-weight: 800;
      user-select: none;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 10px;
      border: 1px solid #00000022;
      background: #fafafa;
    }
    .dba-pick-filterchk input[type="checkbox"]{
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #ea0000;
    }
    .dba-pick-filterchk[data-disabled="1"]{
      opacity: 0.45;
      cursor: not-allowed;
    }
    .dba-pick-filterchk[data-disabled="1"] input{
      cursor: not-allowed;
    }

    .dba-pick-row-selected{
      /* tr 自体に背景が乗らない実装もあるため、td 側も別途指定する */
      background: rgba(255,0,0,0.22) !important;
      outline: 3px solid rgba(255,0,0,0.75) !important;
      outline-offset: -2px !important;
    }
    /* 多くのテーブルは td に背景が乗っているため、td にも強制適用する */
    .dba-pick-row-selected > td,
    .dba-pick-row-selected > th{
      background: rgba(255,0,0,0.22) !important;
      /* “赤いフィルタ”っぽく見せるため、内側に薄赤のシェードも追加 */
      box-shadow: inset 0 0 0 9999px rgba(255,0,0,0.10) !important;
    }
    /* クリック対象が a 等でも選択が分かりやすいように */
    .dba-pick-row-selected a{
      color: #000 !important;
      font-weight: 800;
    }
    .dba-backup-textarea{
      width: 100%;
      box-sizing: border-box;
      min-height: 240px;
      resize: vertical;
      padding: 10px 12px;
      border: 2px solid #000;
      border-radius: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.95em;
      line-height: 1.25em;
    }
  `;
  // ============================================================
  // △ここまで△ CSS 定義ゾーン（集中管理）
  // ============================================================

  function addStyle(cssText) {
    if (typeof GM_addStyle === 'function') {
      GM_addStyle(cssText);
      return;
    }
    const style = document.createElement('style');
    style.textContent = cssText;
    document.documentElement.appendChild(style);
  }

  // =========================
  // 設定（保存・適用）
  // =========================
  const LS_KEY = 'dba.settings.v1';

  const DEFAULT_SETTINGS = {
    scale: { rb: 100, hc: 100, l: 100 },
    layer: { textOpacity: 100 } // 0〜100（レイヤー文字濃度）
  };

  function clampInt(n, min, max){
    const x = Number.parseInt(n, 10);
    if (!Number.isFinite(x)) return min;
    return Math.max(min, Math.min(max, x));
  }

  function sanitizeScale(v){
    // 指定範囲外や不正値は 100 に戻す
    const x = Number.parseInt(v, 10);
    if (!Number.isFinite(x)) return 100;
    if (x < 100 || x > 200) return 100;
    return x;
  }

  function sanitizeOpacity(v){
    const x = Number.parseInt(v, 10);
    if(!Number.isFinite(x)) return 100;
    if(x < 0) return 0;
    if(x > 100) return 100;
    return x;
  }

  function loadSettings(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
      const obj = JSON.parse(raw);
      const out = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
      if(obj && obj.scale){
        for(const k of ['rb','hc','l']){
          out.scale[k] = sanitizeScale(obj.scale[k]);
        }
      }
      if(obj && obj.layer){
        out.layer.textOpacity = sanitizeOpacity(obj.layer.textOpacity);
      }
      return out;
    }catch(_e){
      return JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
    }
  }

  function saveSettings(s){
    try{
      const out = {
        scale: { rb: sanitizeScale(s?.scale?.rb), hc: sanitizeScale(s?.scale?.hc), l: sanitizeScale(s?.scale?.l) },
        layer: { textOpacity: sanitizeOpacity(s?.layer?.textOpacity) }
      };
      localStorage.setItem(LS_KEY, JSON.stringify(out));
    }catch(_e){}
  }

  function getModeLabel(m){
    if(m === 'rb') return 'レッドvsブルーモード';
    if(m === 'hc') return 'ハードモード';
    if(m === 'l') return 'ラダーモード';
    return m;
  }

  function applyScaleToGrid(scalePct){
    const grid = document.querySelector('.grid');
    if(!grid) return false;

    const s = sanitizeScale(scalePct);
    const scale = s / 100;

    // grid-template-columns / rows を更新（repeat(n, 35px) の px を拡大）
    const gtc = grid.style.gridTemplateColumns || '';
    const gtr = grid.style.gridTemplateRows || '';
    const m1 = gtc.match(/repeat\(\s*(\d+)\s*,\s*(\d+)px\s*\)/);
    const m2 = gtr.match(/repeat\(\s*(\d+)\s*,\s*(\d+)px\s*\)/);

    if(m1){
      const n = Number(m1[1]);
      const base = Number(m1[2]);
      const px = Math.max(1, Math.round(base * scale));
      grid.style.gridTemplateColumns = `repeat(${n}, ${px}px)`;
    }
    if(m2){
      const n = Number(m2[1]);
      const base = Number(m2[2]);
      const px = Math.max(1, Math.round(base * scale));
      grid.style.gridTemplateRows = `repeat(${n}, ${px}px)`;
    }

    // 各セルサイズ（ページ側で inline 指定されても上書き）
    const cellPx = Math.max(1, Math.round(30 * scale));
    for(const el of grid.querySelectorAll('.cell')){
      el.style.width = cellPx + 'px';
      el.style.height = cellPx + 'px';
    }

    scheduleBattlemapLayerSync();
    return true;
  }

  function applyScaleToCanvasWrap(scalePct){
    const wrap = document.getElementById('gridWrap');
    if(!wrap) return false;
    const s = sanitizeScale(scalePct);
    const scale = s / 100;
    wrap.style.transformOrigin = 'left top';
    wrap.style.transform = `scale(${scale})`;
    scheduleBattlemapLayerSync();
    return true;
  }

  function applyLayerTextOpacity(opacityPct){
    const s = sanitizeOpacity(opacityPct);
    const v = (s / 100).toFixed(2);
    document.documentElement.style.setProperty('--dba-layer-text-opacity', v);
  }

  function getRbGridSizeFromPageScript(){
    // RBページの IIFE スクリプト内に "const GRID_SIZE = N;" がある想定
    const scripts = Array.from(document.querySelectorAll('script'));
    for(const sc of scripts){
      const t = sc.textContent || '';
      if(!t) continue;
      if(t.includes('const GRID_SIZE') && t.includes('modeQS') && t.includes('&m=rb')){
        const m = t.match(/const\s+GRID_SIZE\s*=\s*(\d+)\s*;/);
        if(m) return Number(m[1]);
      }
      // modeQS が無いサンプルにも備えて、rb らしさで緩めに判定
      if(t.includes('const GRID_SIZE') && t.includes('gridWrap') && t.includes('gridOverlay')){
        const m = t.match(/const\s+GRID_SIZE\s*=\s*(\d+)\s*;/);
        if(m) return Number(m[1]);
      }
    }
    return null;
  }

  function ensureRbPointerFix(){
    // gridOverlay の既存クリックを潰し、スケール後も正しく座標→r,c を解釈する
    const overlay = document.getElementById('gridOverlay');
    if(!overlay) return false;

    if(overlay.dataset.dbaPointerFix === '1') return true;
    overlay.dataset.dbaPointerFix = '1';

    function clientXY(evt){
      if(evt.touches && evt.touches[0]) return {x: evt.touches[0].clientX, y: evt.touches[0].clientY};
      return {x: evt.clientX, y: evt.clientY};
    }

    function onPointerCapture(evt){
      const GRID_SIZE = getRbGridSizeFromPageScript() || 16;

      // 既存ハンドラを無効化
      evt.preventDefault();
      evt.stopImmediatePropagation();

      const rect = overlay.getBoundingClientRect();
      const {x,y} = clientXY(evt);
      const rx = x - rect.left;
      const ry = y - rect.top;
      if(rx < 0 || ry < 0 || rx >= rect.width || ry >= rect.height) return;

      const cellCss = rect.width / GRID_SIZE; // 見た目上のセルサイズ
      const c = Math.floor(rx / cellCss);
      const r = Math.floor(ry / cellCss);
      if(r<0||c<0||r>=GRID_SIZE||c>=GRID_SIZE) return;
      // 遷移を抑止し、セル詳細をモーダル表示
      openCellDetailModal(r, c);
    }

    overlay.addEventListener('click', onPointerCapture, true);
    overlay.addEventListener('touchstart', onPointerCapture, { capture: true, passive: false });
    return true;
  }

  // =========================
  // セル詳細モーダル（セルクリックで表示）
  //  - 詳細ページ: https://donguri.5ch.net/teambattle?r={row}&c={col}&m={mode}
  //  - <header> の次にある <table> を抽出して表示
  //  - table内の form（「エリアに挑む」「アリーナを強化する」「アリーナを弱体化する」等）はそのまま機能
  // =========================
  function buildCellDetailModal(){
    if(document.getElementById('dba-m-cell-detail')) return;

    const dlg = document.createElement('dialog');
    dlg.id = 'dba-m-cell-detail';
    dlg.className = 'dba-m-std';

    // Top
    const top = document.createElement('div');
    top.className = 'dba-modal__top';

    const title = document.createElement('div');
    title.className = 'dba-modal__title';
    title.textContent = 'セル詳細';

    const btnX = document.createElement('button');
    btnX.type = 'button';
    btnX.className = 'dba-btn-x';
    btnX.textContent = '×';

    top.appendChild(title);
    top.appendChild(btnX);

    // Mid
    const mid = document.createElement('div');
    mid.className = 'dba-modal__mid';

    const box = document.createElement('div');
    box.id = 'dba-cell-detail-box';
    box.textContent = '';
    mid.appendChild(box);

    // Bot（Close）
    const bot = document.createElement('div');
    bot.className = 'dba-modal__bot';

    const btnClose = document.createElement('button');
    btnClose.type = 'button';
    btnClose.className = 'dba-btn-close';
    btnClose.textContent = 'Close';
    bot.appendChild(btnClose);

    dlg.appendChild(top);
    dlg.appendChild(mid);
    dlg.appendChild(bot);

    document.body.appendChild(dlg);

    function closeDirect(){
      try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); }
    }

    btnX.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeDirect();
    });

    btnClose.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeDirect();
    });

    // ESC で閉じる
    dlg.addEventListener('cancel', (e) => {
      e.preventDefault();
      closeDirect();
    });

    // ★重要：セル詳細内の form submit（例：「エリアに挑む」）を捕捉して遷移抑止 → 戦闘結果モーダル表示
    // - capture で先に止める
    dlg.addEventListener('submit', (e) => {
      const form = e.target;
      if(!(form instanceof HTMLFormElement)) return;
      // セル詳細ボックス配下の form だけ対象
      if(!box.contains(form)) return;

      // 「エリアに挑む」以外（強化/弱体化等）は従来通り遷移させても良いが、
      // ここでは要望に合わせて
      //  - 「エリアに挑む / エリアに挑戦」
      //  - 「このエリアを捕らえよ」
      // を戦闘結果モーダル化する
      // （他の2ボタンは現状の機能維持：＝通常submitで遷移）
      const submitter = e.submitter;
      const submitText = sanitizeText(submitter && (submitter.textContent || submitter.value || ''));
      if(
        !submitText.includes('エリアに挑む') &&
        !submitText.includes('エリアに挑戦') &&
        !submitText.includes('このエリアを捕らえよ')
      ) return;

      e.preventDefault();
      e.stopImmediatePropagation();
      fetchFormAndShowBattleResult(form, submitter).catch(() => {
        // 失敗時は控えめに
        alert('戦闘結果の取得に失敗しました。');
      });
    }, true);
  }

  // =========================
  // 戦闘結果モーダル（「エリアに挑む」結果を表示）
  // =========================
  function buildBattleResultModal(){
    if(document.getElementById('dba-m-battle-result')) return;

    const dlg = document.createElement('dialog');
    dlg.id = 'dba-m-battle-result';
    dlg.className = 'dba-m-std';

    const top = document.createElement('div');
    top.className = 'dba-modal__top';

    const title = document.createElement('div');
    title.className = 'dba-modal__title';
    title.textContent = '戦闘結果';

    const btnX = document.createElement('button');
    btnX.type = 'button';
    btnX.className = 'dba-btn-x';
    btnX.textContent = '×';

    top.appendChild(title);
    top.appendChild(btnX);

    const mid = document.createElement('div');
    mid.className = 'dba-modal__mid';

    const box = document.createElement('div');
    box.id = 'dba-battle-result-box';
    box.textContent = '';
    mid.appendChild(box);

    const bot = document.createElement('div');
    bot.className = 'dba-modal__bot';

    const btnClose = document.createElement('button');
    btnClose.type = 'button';
    btnClose.className = 'dba-btn-close';
    btnClose.textContent = 'Close';
    bot.appendChild(btnClose);

    dlg.appendChild(top);
    dlg.appendChild(mid);
    dlg.appendChild(bot);
    document.body.appendChild(dlg);

    function closeDirect(){
      try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); }
    }

    btnX.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeDirect();
    });
    btnClose.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeDirect();
    });

    dlg.addEventListener('cancel', (e) => {
      e.preventDefault();
      closeDirect();
    });
  }

  function openBattleResultModalWithNode(nodeOrText, titleText){
    buildBattleResultModal();
    const dlg = document.getElementById('dba-m-battle-result');
    const box = document.getElementById('dba-battle-result-box');
    const title = dlg ? dlg.querySelector('.dba-modal__title') : null;
    if(!dlg || !box) return;
    if(title) title.textContent = titleText || '戦闘結果';

    box.textContent = '';
    if(typeof nodeOrText === 'string'){
      const pre = document.createElement('div');
      pre.className = 'dba-battle-result-text';
      pre.textContent = nodeOrText;
      box.appendChild(pre);
    }else if(nodeOrText instanceof Node){
      box.appendChild(nodeOrText);
    }else{
      const pre = document.createElement('div');
      pre.className = 'dba-battle-result-text';
      pre.textContent = '結果を表示できませんでした。';
      box.appendChild(pre);
    }

    try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
  }

  function extractBattleResultBlock(doc){
    // 戦闘結果はページ実装差があり得るため、特徴語を含む要素を優先して拾う
    // 例（サンプル）: 「アリーナチャレンジ開始」「ターン」「が勝った！」等 :contentReference[oaicite:2]{index=2}
    const keywords = [
      'アリーナチャレンジ開始',
      'ターン',
      'が勝った',
      'チャレンジに成功',
      'アリーナリーダー',
      // 空きセルの「このエリアを捕らえよ」→「リーダーになった」等の短文返却対策
      'リーダーになった',
      'リーダーになりました',
      'あなたはリーダー'
    ];

    const all = Array.from(doc.querySelectorAll('body *'));
    let best = null;
    let bestScore = 0;
    for(const el of all){
      const t = sanitizeText(el.textContent || '');
      if(!t) continue;
      let score = 0;
      for(const k of keywords){
        if(t.includes(k)) score++;
      }
      if(score > bestScore){
        bestScore = score;
        best = el;
      }
    }

    // ほどほど以上ヒットしている要素があれば、それを（親がpre/divなら親を）返す
    // ただし「リーダーになった」系の短文はヒット数が1でも拾えるようにする
    if(best && (bestScore >= 2 || (bestScore >= 1 && sanitizeText(best.textContent || '').includes('リーダー')))){
      const p = best.closest('pre, div, section, article, main') || best;
      return p;
    }

    // fallback：header の次の主要ブロック
    const header = doc.querySelector('header');
    if(header){
      let el = header.nextElementSibling;
      // table（セル詳細）を飛ばす
      while(el && el.tagName && el.tagName.toLowerCase() === 'table'){
        el = el.nextElementSibling;
      }
      if(el) return el;
    }

    return doc.body || null;
  }

  async function fetchFormAndShowBattleResult(form, submitter){
    // submitter がある場合、その name/value も FormData に含める（ボタン識別が必要な実装に備える）
    const method = (form.method || 'GET').toUpperCase();
    const action = form.getAttribute('action') || location.href;
    const url = new URL(action, location.origin);

    const fd = new FormData(form);
    if(submitter && submitter.name){
      // 同名が既に入っていても上書きせず追加（サーバー実装依存）
      fd.append(submitter.name, submitter.value || sanitizeText(submitter.textContent || ''));
    }

    // 戦闘結果モーダルを先に開いて「取得中…」を出す（体感をよくする）
    openBattleResultModalWithNode('戦闘結果を取得中…', '戦闘結果');

    let fetchUrl = url.toString();
    let init = { method, credentials:'include', cache:'no-store' };

    if(method === 'GET'){
      // GET は query へ
      for(const [k,v] of fd.entries()){
        url.searchParams.append(k, String(v));
      }
      fetchUrl = url.toString();
    }else{
      // POST 等は body に
      init.body = fd;
    }

    const res = await fetch(fetchUrl, init);
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    const bodyText = await res.text();

    // 返却が HTML ではなく、短いテキスト（例：「リーダーになった」）だけのケースに備える
    if(!ct.includes('text/html')){
      openBattleResultModalWithNode(bodyText || '結果を表示できませんでした。', '戦闘結果');
      return;
    }

    const doc = new DOMParser().parseFromString(bodyText, 'text/html');

    const block = extractBattleResultBlock(doc);
    if(block){
      // 表示用に import（scriptは inert なので、結果表示だけなら問題なし）
      const imported = document.importNode(block, true);
      // ただし余計なフォーム等が混ざっても良い（表示目的）。見やすさ優先でテキスト整形 fallback を用意。
      const text = sanitizeText(imported.textContent || '');
      // 中身が薄い場合は body のテキストを表示
      if(text.length < 8){
        openBattleResultModalWithNode((doc.body && doc.body.innerText) ? doc.body.innerText : '結果を表示できませんでした。', '戦闘結果');
        return;
      }

      // できるだけ「結果本文」っぽく見せるため、imported をテキスト表示に寄せる（縦長にも対応）
      // （DOMそのまま表示が崩れる場合があるので、まずはテキストで確実に見せる）
      openBattleResultModalWithNode((doc.body && doc.body.innerText) ? doc.body.innerText : imported.textContent, '戦闘結果');
      return;
    }

    openBattleResultModalWithNode((doc.body && doc.body.innerText) ? doc.body.innerText : '結果を表示できませんでした。', '戦闘結果');
  }

  function findFirstTableAfterHeader(doc){
    const tables = Array.from(doc.querySelectorAll('table'));
    if(tables.length === 0) return null;
    const header = doc.querySelector('header');
    if(!header) return tables[0];
    for(const t of tables){
      try{
        const pos = header.compareDocumentPosition(t);
        if(pos & Node.DOCUMENT_POSITION_FOLLOWING) return t;
      }catch(_e){}
    }
    return tables[0];
  }

  async function openCellDetailModal(row, col){
    const openNow = async () => {
      buildCellDetailModal();
      const dlg = document.getElementById('dba-m-cell-detail');
      const box = document.getElementById('dba-cell-detail-box');
      const title = dlg ? dlg.querySelector('.dba-modal__title') : null;
      if(!dlg || !box) return;

      if(title) title.textContent = `セル詳細 (${row},${col})`;
      box.textContent = '読み込み中…';

      try{
        const url = `https://donguri.5ch.net/teambattle?r=${row}&c=${col}&m=${mode}`;
        const res = await fetch(url, { method:'GET', credentials:'include', cache:'no-store' });
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const table = findFirstTableAfterHeader(doc);
        if(!table){
          box.textContent = 'テーブルが見つかりませんでした。';
        }else{
          // table をそのまま移植（form submit を維持）
          const imported = document.importNode(table, true);
          box.textContent = '';
          box.appendChild(imported);
        }
      }catch(_e){
        box.textContent = '取得に失敗しました。';
      }

      try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
    };

    if(document.body) await openNow();
    else document.addEventListener('DOMContentLoaded', () => { openNow(); }, { once:true });
  }

  // HC/L：バトルマップ内クリックを捕捉して遷移を抑止→モーダル表示
  //  - a[href*="teambattle?r="] があれば URL から r,c を読む
  //  - それが無い場合は .cell の index と列数から r,c を推定
  function initBattlemapCellClickIntercept(){
    if(document.documentElement.dataset.dbaCellIntercept === '1') return;
    document.documentElement.dataset.dbaCellIntercept = '1';

    document.addEventListener('click', (evt) => {
      if(mode === 'rb') return; // RB は gridOverlay 側で捕捉済み

      const grid = document.querySelector('.grid');
      if(!grid) return;
      if(!evt.target) return;

      // grid 内だけ対象
      const t = evt.target;
      const inGrid = (t instanceof Element) ? !!t.closest('.grid') : false;
      if(!inGrid) return;

      // 1) まずリンク遷移を狙っている場合（href から r,c を抽出）
      const a = (t instanceof Element) ? t.closest('a[href]') : null;
      if(a && a.getAttribute('href')){
        const href = a.getAttribute('href');
        if(href && href.includes('teambattle') && href.includes('r=') && href.includes('c=')){
          try{
            const u = new URL(href, location.origin);
            const r = Number(u.searchParams.get('r'));
            const c = Number(u.searchParams.get('c'));
            if(Number.isFinite(r) && Number.isFinite(c)){
              evt.preventDefault();
              evt.stopImmediatePropagation();
              openCellDetailModal(r, c);
              return;
            }
          }catch(_e){}
        }
      }

      // 2) リンクが無い/取れない場合：.cell の index から推定
      const cell = (t instanceof Element) ? t.closest('.cell') : null;
      if(!cell) return;
      const cells = Array.from(grid.querySelectorAll('.cell'));
      const idx = cells.indexOf(cell);
      if(idx < 0) return;

      const spec = getHcLGridSpec(grid);
      const cols = spec.cols || 0;
      if(cols <= 0) return;
      const r = Math.floor(idx / cols);
      const c = idx % cols;

      evt.preventDefault();
      evt.stopImmediatePropagation();
      openCellDetailModal(r, c);
    }, true); // capture：既存遷移より先に止める
  }

  // =========================
  // バトルマップ透明レイヤー
  // =========================
  let dbaLayerInited = false;
  let dbaLayerRAF = 0;
  let dbaLayerLastKey = '';
  let dbaLayerResizeObs = null;
  let dbaLayerMutObs = null;

  function ensureBattlemapLayerDOM(){
    if(document.getElementById('dba-battlemap-layer')) return;
    const root = document.createElement('div');
    root.id = 'dba-battlemap-layer';
    const grid = document.createElement('div');
    grid.id = 'dba-battlemap-layer-grid';
    root.appendChild(grid);
    (document.body || document.documentElement).appendChild(root);
  }

  function rebuildLayerCells(rows, cols){
    const grid = document.getElementById('dba-battlemap-layer-grid');
    if(!grid) return;
    grid.textContent = '';
    const frag = document.createDocumentFragment();
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = document.createElement('div');
        cell.className = 'dba-layer-cell';
        cell.dataset.row = String(r);
        cell.dataset.col = String(c);
        const content = document.createElement('div');
        content.className = 'dba-layer-cell__content';
        content.textContent = ''; // 将来：ここに文字列/絵文字を配置
        cell.appendChild(content);
        frag.appendChild(cell);
      }
    }
    grid.appendChild(frag);
  }

  function getHcLGridSpec(gridEl){
    const cs = getComputedStyle(gridEl);
    const cols = (cs.gridTemplateColumns || '').trim().split(/\s+/).filter(Boolean);
    const rows = (cs.gridTemplateRows || '').trim().split(/\s+/).filter(Boolean);
    const colN = cols.length || 0;
    const rowN = rows.length || 0;
    return {
      rows: rowN,
      cols: colN,
      gtc: cs.gridTemplateColumns,
      gtr: cs.gridTemplateRows,
      gap: cs.gap || `${cs.rowGap || '0px'} ${cs.columnGap || '0px'}`
    };
  }

  function syncBattlemapLayer(){
    const root = document.getElementById('dba-battlemap-layer');
    const grid = document.getElementById('dba-battlemap-layer-grid');
    if(!root || !grid) return false;

    let target = null;
    let spec = null;

    if(mode === 'rb'){
      target = document.getElementById('gridWrap');
      if(!target) return false;
      const n = getRbGridSizeFromPageScript();
      const size = Number.isFinite(n) ? n : 16;
      spec = {
        rows: size,
        cols: size,
        gtc: `repeat(${size}, 1fr)`,
        gtr: `repeat(${size}, 1fr)`,
        gap: '0px'
      };
    }else{
      target = document.querySelector('.grid');
      if(!target) return false;
      spec = getHcLGridSpec(target);
      if(!spec.rows || !spec.cols) return false;
    }

    const rect = target.getBoundingClientRect();
    // rectがゼロのときはまだ描画途中
    if(rect.width <= 1 || rect.height <= 1) return false;

    // 位置・サイズ追従（position:fixed）
    root.style.left = rect.left + 'px';
    root.style.top = rect.top + 'px';
    root.style.width = rect.width + 'px';
    root.style.height = rect.height + 'px';

    // グリッド仕様追従
    grid.style.gridTemplateColumns = spec.gtc;
    grid.style.gridTemplateRows = spec.gtr;
    grid.style.gap = spec.gap;

    const key = `${mode}:${spec.rows}x${spec.cols}:${spec.gtc}|${spec.gtr}|${spec.gap}`;
    if(key !== dbaLayerLastKey){
      dbaLayerLastKey = key;
      rebuildLayerCells(spec.rows, spec.cols);
    }

    return true;
  }

  function scheduleBattlemapLayerSync(){
    if(dbaLayerRAF) return;
    dbaLayerRAF = requestAnimationFrame(() => {
      dbaLayerRAF = 0;
      syncBattlemapLayer();
    });
  }

  function initBattlemapLayer(){
    if(dbaLayerInited) return;
    dbaLayerInited = true;

    // bodyが無い可能性を考慮
    const start = () => {
      ensureBattlemapLayerDOM();
      // 初期値反映（文字濃度）
      const s = loadSettings();
      applyLayerTextOpacity(s.layer.textOpacity);

      // まず同期
      scheduleBattlemapLayerSync();

      // スクロール・リサイズ追従
      window.addEventListener('scroll', scheduleBattlemapLayerSync, { passive: true });
      window.addEventListener('resize', scheduleBattlemapLayerSync, { passive: true });
      window.addEventListener('orientationchange', scheduleBattlemapLayerSync, { passive: true });
      if(window.visualViewport){
        window.visualViewport.addEventListener('resize', scheduleBattlemapLayerSync, { passive: true });
        window.visualViewport.addEventListener('scroll', scheduleBattlemapLayerSync, { passive: true });
      }

      // ターゲットの変化追従（サイズ・DOM）
      const target = (mode === 'rb') ? document.getElementById('gridWrap') : document.querySelector('.grid');
      if(target && typeof ResizeObserver === 'function'){
        dbaLayerResizeObs = new ResizeObserver(() => scheduleBattlemapLayerSync());
        dbaLayerResizeObs.observe(target);
      }
      dbaLayerMutObs = new MutationObserver(() => scheduleBattlemapLayerSync());
      dbaLayerMutObs.observe(document.documentElement, { childList: true, subtree: true, attributes: true });
    };

    if(document.body) start();
    else document.addEventListener('DOMContentLoaded', start, { once: true });
  }

  function applyCurrentModeScale(){
    const settings = loadSettings();
    applyLayerTextOpacity(settings.layer.textOpacity);
    if(mode === 'rb'){
      applyScaleToCanvasWrap(settings.scale.rb);
      ensureRbPointerFix();
      scheduleBattlemapLayerSync();
      return;
    }
    if(mode === 'hc'){
      applyScaleToGrid(settings.scale.hc);
      scheduleBattlemapLayerSync();
      return;
    }
    if(mode === 'l'){
      applyScaleToGrid(settings.scale.l);
      scheduleBattlemapLayerSync();
      return;
    }
  }

  // =========================
  // 戦況情報（全セル巡回→レイヤー表示）
  // =========================
  function raf2(){
    return new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));
  }

  function sanitizeText(s){
    if(!s) return '';
    return String(s).replace(/\s+/g,' ').trim();
  }

  // =========================
  // 装備ロスター（保存・UI）
  // =========================
  const ROSTER_LS_KEY = 'dba.roster.v1';

  function pad2(n){ return String(n).padStart(2,'0'); }
  function yyyymmddLocal(){
    const d = new Date();
    return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
  }
  function nowIso(){ try{ return new Date().toISOString(); }catch(_e){ return ''; } }

  function loadRosterStore(){
    try{
      const raw = localStorage.getItem(ROSTER_LS_KEY);
      if(!raw){
        return { activeId: null, rosters: {} };
      }
      const obj = JSON.parse(raw);
      if(!obj || typeof obj !== 'object') return { activeId: null, rosters: {} };
      if(!obj.rosters || typeof obj.rosters !== 'object') obj.rosters = {};
      if(!('activeId' in obj)) obj.activeId = null;
      return obj;
    }catch(_e){
      return { activeId: null, rosters: {} };
    }
  }

  function saveRosterStore(store){
    try{
      localStorage.setItem(ROSTER_LS_KEY, JSON.stringify(store));
    }catch(_e){}
  }

  function createRosterIfNeeded(){
    const store = loadRosterStore();
    const ids = Object.keys(store.rosters || {});
    if(store.activeId && store.rosters[store.activeId]){
      return store;
    }
    if(ids.length > 0){
      store.activeId = ids[0];
      saveRosterStore(store);
      return store;
    }
    // 新規作成
    const id = `r_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const title = `装備ロスター_${yyyymmddLocal()}`;
    store.rosters[id] = {
      id,
      title,
      createdAt: nowIso(),
      updatedAt: nowIso(),
      presets: {}, // { "name": [weaponId, armorId, necklaceId] }
      presetOrder: [] // 表示順を保持（追加順／バックアップJSON記述順）
    };
    store.activeId = id;
    saveRosterStore(store);
    return store;
  }

  function getActiveRoster(){
    const store = createRosterIfNeeded();
    const r = store.rosters[store.activeId];
    return { store, roster: r };
  }

  function setRosterTitle(newTitle){
    const { store, roster } = getActiveRoster();
    roster.title = sanitizeText(newTitle) || roster.title;
    roster.updatedAt = nowIso();
    store.rosters[store.activeId] = roster;
    saveRosterStore(store);
  }

  function overwriteRosterFromObject(obj){
    // バックアップ用：active roster の全体を上書き（最低限 title/presets を使用）
    const { store, roster } = getActiveRoster();
    if(!obj || typeof obj !== 'object') throw new Error('Invalid JSON object');
    const title = sanitizeText(obj.title || roster.title);
    const presets = (obj.presets && typeof obj.presets === 'object') ? obj.presets : {};
    const cleaned = {};
    const order = [];
    for(const k of Object.keys(presets)){
      // バックアップJSONの記述順を尊重して order に積む
      const name = sanitizeText(k);
      if(!name) continue;
      const v = presets[k];
      if(!Array.isArray(v) || v.length !== 3) continue;
      cleaned[name] = [
        (v[0] === null || Number.isFinite(Number(v[0]))) ? (v[0] === null ? null : Number(v[0])) : null,
        (v[1] === null || Number.isFinite(Number(v[1]))) ? (v[1] === null ? null : Number(v[1])) : null,
        (v[2] === null || Number.isFinite(Number(v[2]))) ? (v[2] === null ? null : Number(v[2])) : null
      ];
      order.push(name);
    }
    roster.title = title || roster.title;
    roster.presets = cleaned;
    // 表示順はバックアップの記述順にする（ここで並び替えない）
    roster.presetOrder = order;
    roster.updatedAt = nowIso();
    store.rosters[store.activeId] = roster;
    saveRosterStore(store);
  }

  function deleteActiveRosterAndSwitch(){
    const store = loadRosterStore();
    if(store.activeId && store.rosters && store.rosters[store.activeId]){
      delete store.rosters[store.activeId];
    }
    const ids = Object.keys(store.rosters || {});
    if(ids.length > 0){
      store.activeId = ids[0];
      saveRosterStore(store);
      return createRosterIfNeeded();
    }
    // 1つも無ければ新規作成
    store.activeId = null;
    store.rosters = {};
    saveRosterStore(store);
    return createRosterIfNeeded();
  }

  function setPreset(name, triple){
    const { store, roster } = getActiveRoster();
    const n = sanitizeText(name);
    if(!n) throw new Error('プリセット名が空です');
    if(!Array.isArray(triple) || triple.length !== 3) throw new Error('Invalid preset triple');
    roster.presets = roster.presets || {};
    roster.presetOrder = Array.isArray(roster.presetOrder) ? roster.presetOrder : [];
    const existed = !!(roster.presets && Object.prototype.hasOwnProperty.call(roster.presets, n));
    roster.presets[n] = [
      (triple[0] === null) ? null : Number(triple[0]),
      (triple[1] === null) ? null : Number(triple[1]),
      (triple[2] === null) ? null : Number(triple[2])
    ];
    // 既存プリセットを上書きする場合は順序は維持、新規だけ末尾追加
    if(!existed){
      roster.presetOrder.push(n);
    }
    roster.updatedAt = nowIso();
    store.rosters[store.activeId] = roster;
    saveRosterStore(store);
  }

  function deletePreset(name){
    const { store, roster } = getActiveRoster();
    const n = sanitizeText(name);
    if(!n) return false;
    if(roster.presets && roster.presets[n]){
      delete roster.presets[n];
      // 表示順配列からも削除
      if(Array.isArray(roster.presetOrder)){
        roster.presetOrder = roster.presetOrder.filter(x => x !== n);
      }
      roster.updatedAt = nowIso();
      store.rosters[store.activeId] = roster;
      saveRosterStore(store);
      return true;
    }
    return false;
  }

  function presetMetaText(triple){
    const w = (triple && triple[0] != null) ? `W:${triple[0]}` : 'W:-';
    const a = (triple && triple[1] != null) ? `A:${triple[1]}` : 'A:-';
    const n = (triple && triple[2] != null) ? `N:${triple[2]}` : 'N:-';
    return `${w} ${a} ${n}`;
  }

  async function equipById(id){
    if(id == null) return true;
    const url = `https://donguri.5ch.net/equip/${Number(id)}`;
    const res = await fetch(url, { method:'GET', credentials:'include', cache:'no-store' });
    if(!res.ok) throw new Error(`equip failed: ${res.status}`);
    return true;
  }

  async function equipPresetByName(name){
    const { roster } = getActiveRoster();
    const n = sanitizeText(name);
    const triple = roster && roster.presets ? roster.presets[n] : null;
    if(!triple) throw new Error('preset not found');
    // 順番：武器→防具→首
    await equipById(triple[0]);
    await equipById(triple[1]);
    await equipById(triple[2]);
    return true;
  }

  // =========================
  // 装備ロスター：モーダル UI
  // =========================
  function buildRosterModal(){
    if(document.getElementById('dba-m-roster')) return;

    const dlg = document.createElement('dialog');
    dlg.id = 'dba-m-roster';
    dlg.className = 'dba-m-std';

    const top = document.createElement('div');
    top.className = 'dba-modal__top';
    const title = document.createElement('div');
    title.className = 'dba-modal__title';
    title.textContent = '装備ロスター';
    const btnX = document.createElement('button');
    btnX.type = 'button';
    btnX.className = 'dba-btn-x';
    btnX.textContent = '×';
    top.appendChild(title);
    top.appendChild(btnX);

    const mid = document.createElement('div');
    mid.className = 'dba-modal__mid';

    const box = document.createElement('div');
    box.id = 'dba-roster-box';
    mid.appendChild(box);

    const bot = document.createElement('div');
    bot.className = 'dba-modal__bot';
    const btnClose = document.createElement('button');
    btnClose.type = 'button';
    btnClose.className = 'dba-btn-close';
    btnClose.textContent = 'Close';
    bot.appendChild(btnClose);

    dlg.appendChild(top);
    dlg.appendChild(mid);
    dlg.appendChild(bot);
    document.body.appendChild(dlg);

    function closeDirect(){
      try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); }
    }
    btnX.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); closeDirect(); });
    btnClose.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); closeDirect(); });
    dlg.addEventListener('cancel', (e) => { e.preventDefault(); closeDirect(); });
  }

  function renderRosterModalState(selectedPresetName){
    const box = document.getElementById('dba-roster-box');
    if(!box) return;
    const { roster } = getActiveRoster();
    const title = roster ? roster.title : '装備ロスター';
    const presets = roster && roster.presets ? roster.presets : {};
    // ★並び替え禁止：表示順は presetOrder（追加順／バックアップ記述順）を優先
    const order = Array.isArray(roster && roster.presetOrder) ? roster.presetOrder : [];
    const seen = new Set();
    const names = [];
    // まず order の順に並べる（存在するものだけ）
    for(const nm of order){
      if(!nm) continue;
      if(seen.has(nm)) continue;
      if(Object.prototype.hasOwnProperty.call(presets, nm)){
        names.push(nm);
        seen.add(nm);
      }
    }
    // order に無いキーがあれば末尾に追加（ここでも sort しない）
    for(const nm of Object.keys(presets)){
      if(seen.has(nm)) continue;
      names.push(nm);
      seen.add(nm);
    }

    box.textContent = '';

    // 1段目：ロスタータイトル + 右ボタン群
    const head = document.createElement('div');
    head.className = 'dba-roster-head';

    const headTitle = document.createElement('div');
    headTitle.className = 'dba-roster-title';
    headTitle.textContent = title;

    const headBtns = document.createElement('div');
    headBtns.className = 'dba-roster-head-btns';

    const btnRename = document.createElement('button');
    btnRename.type = 'button';
    btnRename.className = 'dba-btn-mini';
    btnRename.textContent = '名前変更';

    const btnWipe = document.createElement('button');
    btnWipe.type = 'button';
    btnWipe.className = 'dba-btn-mini dba-btn-mini--danger';
    btnWipe.textContent = '全削除';

    const btnBackup = document.createElement('button');
    btnBackup.type = 'button';
    btnBackup.className = 'dba-btn-mini';
    btnBackup.textContent = 'バックアップ';

    headBtns.appendChild(btnRename);
    headBtns.appendChild(btnWipe);
    headBtns.appendChild(btnBackup);

    head.appendChild(headTitle);
    head.appendChild(headBtns);
    box.appendChild(head);

    // 2段目：追加/削除
    const row2 = document.createElement('div');
    row2.className = 'dba-roster-row2';

    const btnAdd = document.createElement('button');
    btnAdd.type = 'button';
    btnAdd.className = 'dba-btn-mini dba-btn-mini--ok';
    btnAdd.textContent = '追加';

    const btnDel = document.createElement('button');
    btnDel.type = 'button';
    btnDel.className = 'dba-btn-mini dba-btn-mini--danger';
    btnDel.textContent = '削除';
    btnDel.disabled = !selectedPresetName;

    row2.appendChild(btnAdd);
    row2.appendChild(btnDel);
    box.appendChild(row2);

    // リスト
    const list = document.createElement('div');
    list.className = 'dba-roster-list';
    if(names.length === 0){
      const empty = document.createElement('div');
      empty.style.padding = '10px';
      empty.style.fontWeight = '700';
      empty.textContent = 'プリセットがありません。';
      list.appendChild(empty);
    }else{
      for(const nm of names){
        const triple = presets[nm];
        const item = document.createElement('div');
        item.className = 'dba-roster-item';
        item.dataset.name = nm;
        item.dataset.selected = (nm === selectedPresetName) ? '1' : '0';

        const n = document.createElement('div');
        n.className = 'dba-roster-item__name';
        n.textContent = nm;

        const m = document.createElement('div');
        m.className = 'dba-roster-item__meta';
        m.textContent = presetMetaText(triple);

        item.appendChild(n);
        item.appendChild(m);

        item.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          // クリック＝選択 + 装備適用
          renderRosterModalState(nm);
          try{
            // 体感のため、戦闘結果モーダルを流用して「処理中…」を表示（結果表示ではなくステータス表示）
            openBattleResultModalWithNode(`装備切替中…\n${nm}\n${presetMetaText(presets[nm])}`, '装備ロスター');
            await equipPresetByName(nm);
            openBattleResultModalWithNode(`装備切替完了\n${nm}`, '装備ロスター');
          }catch(_e2){
            openBattleResultModalWithNode(`装備切替に失敗しました\n${nm}`, '装備ロスター');
          }
        });

        list.appendChild(item);
      }
    }
    box.appendChild(list);

    // --- handlers ---
    btnRename.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openRosterRenameModal(title, (newName) => {
        setRosterTitle(newName);
        renderRosterModalState(selectedPresetName || null);
      });
    });

    btnWipe.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openRosterWipeModal(() => {
        deleteActiveRosterAndSwitch();
        renderRosterModalState(null);
      });
    });

    btnBackup.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openRosterBackupModal(() => {
        renderRosterModalState(selectedPresetName || null);
      });
    });

    btnAdd.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openRosterAddPresetModal(() => {
        renderRosterModalState(null);
      });
    });

    btnDel.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      if(!selectedPresetName) return;
      // 軽い確認（ここは要求に無いので標準 alert で簡易）
      const ok = confirm(`プリセット「${selectedPresetName}」を削除しますか？`);
      if(!ok) return;
      deletePreset(selectedPresetName);
      renderRosterModalState(null);
    });
  }

  function openRosterModal(){
    const openNow = () => {
      buildRosterModal();
      createRosterIfNeeded();
      renderRosterModalState(null);
      const dlg = document.getElementById('dba-m-roster');
      if(!dlg) return;
      try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
    };
    if(document.body) openNow();
    else document.addEventListener('DOMContentLoaded', openNow, { once:true });
  }

  // ---- 名前変更 modal ----
  function openRosterRenameModal(currentTitle, onOK){
    const ensure = () => {
      if(document.getElementById('dba-m-roster-rename')) return;
      const dlg = document.createElement('dialog');
      dlg.id = 'dba-m-roster-rename';
      dlg.className = 'dba-m-std';

      const top = document.createElement('div');
      top.className = 'dba-modal__top';
      const t = document.createElement('div');
      t.className = 'dba-modal__title';
      t.textContent = '名前変更';
      const x = document.createElement('button');
      x.type = 'button';
      x.className = 'dba-btn-x';
      x.textContent = '×';
      top.appendChild(t); top.appendChild(x);

      const mid = document.createElement('div');
      mid.className = 'dba-modal__mid';
      const input = document.createElement('input');
      input.type = 'text';
      input.id = 'dba-roster-rename-input';
      input.className = 'dba-add-name';
      input.value = currentTitle || '';
      mid.appendChild(input);

      const bot = document.createElement('div');
      bot.className = 'dba-modal__bot';
      const ok = document.createElement('button');
      ok.type = 'button';
      ok.className = 'dba-btn-ok';
      ok.textContent = 'OK';
      const cancel = document.createElement('button');
      cancel.type = 'button';
      cancel.className = 'dba-btn-close';
      cancel.textContent = 'Cancel';
      bot.appendChild(ok); bot.appendChild(cancel);

      dlg.appendChild(top); dlg.appendChild(mid); dlg.appendChild(bot);
      document.body.appendChild(dlg);

      function closeDirect(){ try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); } }
      x.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
      cancel.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
      dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeDirect(); });
      ok.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        const v = document.getElementById('dba-roster-rename-input')?.value || '';
        try{ onOK && onOK(v); }catch(_e2){}
        closeDirect();
      });
    };

    const openNow = () => {
      ensure();
      const dlg = document.getElementById('dba-m-roster-rename');
      const input = document.getElementById('dba-roster-rename-input');
      if(input) input.value = currentTitle || '';
      if(dlg){
        try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
        try{ input && input.focus(); input && input.select(); }catch(_e2){}
      }
    };
    if(document.body) openNow(); else document.addEventListener('DOMContentLoaded', openNow, { once:true });
  }

  // ---- 全削除（ロスター削除） modal ----
  function openRosterWipeModal(onWipe){
    const ensure = () => {
      if(document.getElementById('dba-m-roster-wipe')) return;
      const dlg = document.createElement('dialog');
      dlg.id = 'dba-m-roster-wipe';
      dlg.className = 'dba-m-std';

      const top = document.createElement('div');
      top.className = 'dba-modal__top';
      const t = document.createElement('div');
      t.className = 'dba-modal__title';
      t.textContent = '全削除';
      const x = document.createElement('button');
      x.type = 'button';
      x.className = 'dba-btn-x';
      x.textContent = '×';
      top.appendChild(t); top.appendChild(x);

      const mid = document.createElement('div');
      mid.className = 'dba-modal__mid';
      const msg = document.createElement('div');
      msg.style.fontWeight = '800';
      msg.style.marginBottom = '10px';
      msg.style.textAlign = 'left';
      msg.textContent = '現在読み込んでいる「装備ロスター」データを削除します。よろしいですか？';
      const chkRow = document.createElement('label');
      chkRow.style.display = 'flex';
      chkRow.style.gap = '8px';
      chkRow.style.alignItems = 'center';
      chkRow.style.fontWeight = '800';
      chkRow.style.textAlign = 'left';
      const chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.id = 'dba-roster-wipe-chk';
      const span = document.createElement('span');
      span.textContent = '削除することを確認しました';
      chkRow.appendChild(chk); chkRow.appendChild(span);
      mid.appendChild(msg);
      mid.appendChild(chkRow);

      const bot = document.createElement('div');
      bot.className = 'dba-modal__bot';
      const wipe = document.createElement('button');
      wipe.type = 'button';
      wipe.className = 'dba-btn-close';
      wipe.textContent = '全削除';
      const back = document.createElement('button');
      back.type = 'button';
      back.className = 'dba-btn-ok';
      back.textContent = 'やめる';
      bot.appendChild(wipe); bot.appendChild(back);

      dlg.appendChild(top); dlg.appendChild(mid); dlg.appendChild(bot);
      document.body.appendChild(dlg);

      function closeDirect(){ try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); } }
      x.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
      back.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
      dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeDirect(); });
      wipe.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        const c = document.getElementById('dba-roster-wipe-chk');
        if(!c || !c.checked){
          alert('確認チェックを入れてください。');
          return;
        }
        try{ onWipe && onWipe(); }catch(_e2){}
        closeDirect();
      });
    };

    const openNow = () => {
      ensure();
      const chk = document.getElementById('dba-roster-wipe-chk');
      if(chk) chk.checked = false;
      const dlg = document.getElementById('dba-m-roster-wipe');
      if(dlg){
        try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
      }
    };
    if(document.body) openNow(); else document.addEventListener('DOMContentLoaded', openNow, { once:true });
  }

  // ---- バックアップ modal（json表示・保存で上書き） ----
  function openRosterBackupModal(onDone){
    const ensure = () => {
      if(document.getElementById('dba-m-roster-backup')) return;
      const dlg = document.createElement('dialog');
      dlg.id = 'dba-m-roster-backup';
      dlg.className = 'dba-m-std';

      const top = document.createElement('div');
      top.className = 'dba-modal__top';
      const t = document.createElement('div');
      t.className = 'dba-modal__title';
      t.textContent = 'バックアップ';
      const x = document.createElement('button');
      x.type = 'button';
      x.className = 'dba-btn-x';
      x.textContent = '×';
      top.appendChild(t); top.appendChild(x);

      const mid = document.createElement('div');
      mid.className = 'dba-modal__mid';
      const ta = document.createElement('textarea');
      ta.id = 'dba-roster-backup-ta';
      ta.className = 'dba-backup-textarea';
      mid.appendChild(ta);

      const bot = document.createElement('div');
      bot.className = 'dba-modal__bot';
      const save = document.createElement('button');
      save.type = 'button';
      save.className = 'dba-btn-apply';
      save.textContent = '保存';
      const cancel = document.createElement('button');
      cancel.type = 'button';
      cancel.className = 'dba-btn-close';
      cancel.textContent = '中止';
      bot.appendChild(save); bot.appendChild(cancel);

      dlg.appendChild(top); dlg.appendChild(mid); dlg.appendChild(bot);
      document.body.appendChild(dlg);

      function closeDirect(){ try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); } }
      x.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
      cancel.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
      dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeDirect(); });
      save.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        const text = document.getElementById('dba-roster-backup-ta')?.value || '';
        try{
          const obj = JSON.parse(text);
          overwriteRosterFromObject(obj);
          try{ onDone && onDone(); }catch(_e2){}
          closeDirect();
        }catch(_e2){
          alert('JSONの解析に失敗しました。');
        }
      });
    };

    const openNow = () => {
      ensure();
      const { roster } = getActiveRoster();
      const obj = {
        title: roster.title,
        presets: roster.presets || {}
      };
      const ta = document.getElementById('dba-roster-backup-ta');
      if(ta){
        try{
          // バックアップ表示の改行を減らす：
          // プリセットの [weaponId, armorId, necklaceId]（長さ3配列）を 1 行に圧縮する
          let text = JSON.stringify(obj, null, 2);
          // 例：
          // [
          //   111111111,
          //   222222222,
          //   333333333
          // ]
          // → [111111111,222222222,333333333]
          text = text.replace(
            /\[\s*\n\s*(null|\d+)\s*,\s*\n\s*(null|\d+)\s*,\s*\n\s*(null|\d+)\s*\n\s*\]/g,
            '[$1,$2,$3]'
          );
          ta.value = text;
        }catch(_e){
          ta.value = '';
        }
      }
      const dlg = document.getElementById('dba-m-roster-backup');
      if(dlg){
        try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
      }
    };
    if(document.body) openNow(); else document.addEventListener('DOMContentLoaded', openNow, { once:true });
  }

  // ---- プリセット追加 modal ----
  function buildRosterAddModal(){
    if(document.getElementById('dba-m-roster-add')) return;
    const dlg = document.createElement('dialog');
    dlg.id = 'dba-m-roster-add';
    dlg.className = 'dba-m-std';

    const top = document.createElement('div');
    top.className = 'dba-modal__top';
    const t = document.createElement('div');
    t.className = 'dba-modal__title';
    t.textContent = 'プリセット追加';
    const x = document.createElement('button');
    x.type = 'button';
    x.className = 'dba-btn-x';
    x.textContent = '×';
    top.appendChild(t); top.appendChild(x);

    const mid = document.createElement('div');
    mid.className = 'dba-modal__mid';

    const wrap = document.createElement('div');
    wrap.className = 'dba-add-wrap';

    const left = document.createElement('div');
    left.className = 'dba-add-left';

    const btnW = document.createElement('button');
    btnW.type = 'button';
    btnW.className = 'dba-btn-mini';
    btnW.textContent = '武器';
    btnW.id = 'dba-add-btn-weapon';

    const btnA = document.createElement('button');
    btnA.type = 'button';
    btnA.className = 'dba-btn-mini';
    btnA.textContent = '防具';
    btnA.id = 'dba-add-btn-armor';

    const btnN = document.createElement('button');
    btnN.type = 'button';
    btnN.className = 'dba-btn-mini';
    btnN.textContent = 'ネックレス';
    btnN.id = 'dba-add-btn-necklace';

    left.appendChild(btnW);
    left.appendChild(btnA);
    left.appendChild(btnN);

    const right = document.createElement('div');
    right.className = 'dba-add-right';

    const selW = document.createElement('div');
    selW.className = 'dba-add-sel';
    selW.id = 'dba-add-sel-weapon';
    selW.textContent = '未選択（武器）';

    const selA = document.createElement('div');
    selA.className = 'dba-add-sel';
    selA.id = 'dba-add-sel-armor';
    selA.textContent = '未選択（防具）';

    const selN = document.createElement('div');
    selN.className = 'dba-add-sel';
    selN.id = 'dba-add-sel-necklace';
    selN.textContent = '未選択（ネックレス）';

    right.appendChild(selW);
    right.appendChild(selA);
    right.appendChild(selN);

    wrap.appendChild(left);
    wrap.appendChild(right);
    mid.appendChild(wrap);

    const name = document.createElement('input');
    name.type = 'text';
    name.className = 'dba-add-name';
    name.id = 'dba-add-preset-name';
    name.placeholder = 'プリセット名';
    mid.appendChild(name);

    const botRow = document.createElement('div');
    botRow.className = 'dba-add-bot';
    const reg = document.createElement('button');
    reg.type = 'button';
    reg.className = 'dba-btn-apply';
    reg.textContent = '登録';
    reg.id = 'dba-add-btn-register';
    const cancel = document.createElement('button');
    cancel.type = 'button';
    cancel.className = 'dba-btn-close';
    cancel.textContent = '中止';
    cancel.id = 'dba-add-btn-cancel';
    botRow.appendChild(reg);
    botRow.appendChild(cancel);
    mid.appendChild(botRow);

    const bot = document.createElement('div');
    bot.className = 'dba-modal__bot';
    const close = document.createElement('button');
    close.type = 'button';
    close.className = 'dba-btn-close';
    close.textContent = 'Close';
    bot.appendChild(close);

    dlg.appendChild(top);
    dlg.appendChild(mid);
    dlg.appendChild(bot);
    document.body.appendChild(dlg);

    function closeDirect(){ try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); } }
    x.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
    close.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
    cancel.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
    dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeDirect(); });
  }

  function openRosterAddPresetModal(onDone){
    const openNow = () => {
      buildRosterAddModal();
      // 状態初期化
      const st = { weaponId: null, armorId: null, necklaceId: null, weaponLabel:'未選択（武器）', armorLabel:'未選択（防具）', necklaceLabel:'未選択（ネックレス）' };
      const selW = document.getElementById('dba-add-sel-weapon');
      const selA = document.getElementById('dba-add-sel-armor');
      const selN = document.getElementById('dba-add-sel-necklace');
      const name = document.getElementById('dba-add-preset-name');
      if(selW) selW.textContent = st.weaponLabel;
      if(selA) selA.textContent = st.armorLabel;
      if(selN) selN.textContent = st.necklaceLabel;
      if(name) name.value = '';

      const btnW = document.getElementById('dba-add-btn-weapon');
      const btnA = document.getElementById('dba-add-btn-armor');
      const btnN = document.getElementById('dba-add-btn-necklace');
      const btnReg = document.getElementById('dba-add-btn-register');
      const dlg = document.getElementById('dba-m-roster-add');

      function refreshLabels(){
        if(selW) selW.textContent = st.weaponLabel;
        if(selA) selA.textContent = st.armorLabel;
        if(selN) selN.textContent = st.necklaceLabel;
      }

      if(btnW){
        btnW.onclick = async (e) => {
          e.preventDefault(); e.stopPropagation();
          try{
            const picked = await openPickItemModal('weapon');
            st.weaponId = picked.id;
            st.weaponLabel = picked.label;
            refreshLabels();
          }catch(_e2){}
        };
      }
      if(btnA){
        btnA.onclick = async (e) => {
          e.preventDefault(); e.stopPropagation();
          try{
            const picked = await openPickItemModal('armor');
            st.armorId = picked.id;
            st.armorLabel = picked.label;
            refreshLabels();
          }catch(_e2){}
        };
      }
      if(btnN){
        btnN.onclick = async (e) => {
          e.preventDefault(); e.stopPropagation();
          try{
            const picked = await openPickItemModal('necklace');
            st.necklaceId = picked.id;
            st.necklaceLabel = picked.label;
            refreshLabels();
          }catch(_e2){}
        };
      }

      if(btnReg){
        btnReg.onclick = (e) => {
          e.preventDefault(); e.stopPropagation();
          const pn = sanitizeText(name && name.value ? name.value : '');
          if(!pn){
            alert('プリセット名を入力してください。');
            return;
          }
          try{
            setPreset(pn, [st.weaponId, st.armorId, st.necklaceId]);
            try{ onDone && onDone(); }catch(_e2){}
            try{ dlg.close(); }catch(_e2){ dlg.removeAttribute('open'); }
          }catch(_e2){
            alert('登録に失敗しました。');
          }
        };
      }

      if(dlg){
        try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
      }
    };
    if(document.body) openNow(); else document.addEventListener('DOMContentLoaded', openNow, { once:true });
  }

  // ---- アイテム選択 modal（/bag から table 抜き出し） ----
  function buildPickItemModal(){
    if(document.getElementById('dba-m-pick-item')) return;
    const dlg = document.createElement('dialog');
    dlg.id = 'dba-m-pick-item';
    dlg.className = 'dba-m-std';

    const top = document.createElement('div');
    top.className = 'dba-modal__top';
    const t = document.createElement('div');
    t.className = 'dba-modal__title';
    t.id = 'dba-pick-title';
    t.textContent = 'アイテム選択';
    const x = document.createElement('button');
    x.type = 'button';
    x.className = 'dba-btn-x';
    x.textContent = '×';
    top.appendChild(t); top.appendChild(x);

    const mid = document.createElement('div');
    mid.className = 'dba-modal__mid';
    const hint = document.createElement('div');
    hint.className = 'dba-pick-hint';
    hint.id = 'dba-pick-hint';
    hint.textContent = '行をクリックして選択してください。';
    const box = document.createElement('div');
    box.id = 'dba-pick-box';
    mid.appendChild(hint);
    mid.appendChild(box);

    const bot = document.createElement('div');
    bot.className = 'dba-modal__bot';
    const ok = document.createElement('button');
    ok.type = 'button';
    ok.className = 'dba-btn-ok';
    ok.textContent = 'OK';
    ok.id = 'dba-pick-ok';
    const cancel = document.createElement('button');
    cancel.type = 'button';
    cancel.className = 'dba-btn-close';
    cancel.textContent = 'Cancel';
    cancel.id = 'dba-pick-cancel';
    bot.appendChild(ok);
    bot.appendChild(cancel);

    dlg.appendChild(top);
    dlg.appendChild(mid);
    dlg.appendChild(bot);
    document.body.appendChild(dlg);

    function closeDirect(){ try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); } }
    x.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
    cancel.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeDirect(); });
    dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeDirect(); });
  }

  function hideColumnsByHeaderText(table, headerTexts){
    if(!table) return [];
    const ths = Array.from(table.querySelectorAll('thead th'));
    const idxs = [];
    for(let i=0;i<ths.length;i++){
      const ht = sanitizeText(ths[i].textContent || '');
      if(headerTexts.includes(ht)){
        idxs.push(i);
      }
    }
    // display none for each index (td/th)
    for(const i of idxs){
      for(const tr of Array.from(table.querySelectorAll('tr'))){
        const cells = Array.from(tr.children);
        const cell = cells[i];
        if(cell && cell.style){
          cell.style.display = 'none';
        }
      }
    }
    return idxs;
  }

  function extractEquipIdFromRow(row){
    if(!row) return null;
    const a = row.querySelector('a[href*="/equip/"]');
    if(!a) return null;
    const href = a.getAttribute('href') || '';
    const m = href.match(/\/equip\/(\d+)/);
    if(!m) return null;
    return Number(m[1]);
  }

  function extractRowLabel(row, kind){
    // 1列目（名前セル）を優先
    const td0 = row ? row.querySelector('td') : null;
    const nm = sanitizeText(td0 ? td0.innerText : '');
    const id = extractEquipIdFromRow(row);
    const k = (kind === 'weapon') ? '武器' : (kind === 'armor') ? '防具' : 'ネックレス';
    if(id != null){
      return `${k}: ${nm || '(名称不明)'} / ID:${id}`;
    }
    return `${k}: ${nm || '(未選択)'} / ID:-`;
  }

  async function fetchBagTableDoc(){
    const url = 'https://donguri.5ch.net/bag';
    const res = await fetch(url, { method:'GET', credentials:'include', cache:'no-store' });
    if(!res.ok) throw new Error(`bag fetch failed: ${res.status}`);
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return doc;
  }

  function pickTableIdByKind(kind){
    if(kind === 'weapon') return 'weaponTable';
    if(kind === 'armor') return 'armorTable';
    return 'necklaceTable';
  }

  function normalizeRgb(s){
    // getComputedStyle() の "rgb(r, g, b)" / "rgba(r, g, b, a)" を比較しやすく
    const t = sanitizeText(String(s || '')).toLowerCase();
    if(!t) return '';
    if(t === 'white') return 'rgb(255, 255, 255)';
    // rgba を rgb に寄せる（a は無視）
    const m = t.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*([0-9.]+))?\s*\)/);
    if(m) return `rgb(${Number(m[1])}, ${Number(m[2])}, ${Number(m[3])})`;
    return t;
  }

  function detectRarityFromRow(tr){
    // ルール：
    // N   … 名称欄に [N] / 背景色 white
    // R   … 名称欄に [R] / 背景色 rgb(63,164,53)
    // SR  … 名称欄に [SR] / 背景色 rgb(33,117,217)
    // SSR … 名称欄に [SSR] / 背景色 rgb(166,51,214)
    // UR  … 名称欄に [UR] / 背景色 rgb(244,93,1)
    const td0 = tr ? tr.querySelector('td') : null;
    const nameText = sanitizeText(td0 ? td0.innerText : '');
    // まずは文字の [XXX] を優先（背景色が上書きされるケースでも安定）
    if(nameText.includes('[UR]')) return 'UR';
    if(nameText.includes('[SSR]')) return 'SSR';
    if(nameText.includes('[SR]')) return 'SR';
    // [R] は [SR]/[SSR]/[UR] に含まれないよう上で先に判定
    if(nameText.includes('[R]')) return 'R';
    if(nameText.includes('[N]')) return 'N';

    // 背景色（td0優先→tr→最初のtd）
    let bg = '';
    try{
      if(td0) bg = normalizeRgb(getComputedStyle(td0).backgroundColor);
      if(!bg || bg === 'transparent' || bg === 'rgba(0, 0, 0, 0)'){
        bg = normalizeRgb(getComputedStyle(tr).backgroundColor);
      }
      if((!bg || bg === 'transparent' || bg === 'rgba(0, 0, 0, 0)') && tr){
        const anyTd = tr.querySelector('td,th');
        if(anyTd) bg = normalizeRgb(getComputedStyle(anyTd).backgroundColor);
      }
    }catch(_e){}

    // 背景色で判定（getComputedStyle は rgb で返る想定）
    if(bg === 'rgb(63, 164, 53)') return 'R';
    if(bg === 'rgb(33, 117, 217)') return 'SR';
    if(bg === 'rgb(166, 51, 214)') return 'SSR';
    if(bg === 'rgb(244, 93, 1)') return 'UR';
    if(bg === 'rgb(255, 255, 255)') return 'N';

    // 何も判定できない場合は N 扱いに寄せる（見落とし回避）
    return 'N';
  }

  function getHeaderIndexByText(table, headerText){
    if(!table) return -1;
    const ths = Array.from(table.querySelectorAll('thead th'));
    for(let i=0;i<ths.length;i++){
      const t = sanitizeText(ths[i].textContent || '');
      if(t === headerText) return i;
    }
    return -1;
  }

  function getRowCellTextByIndex(tr, idx){
    if(!tr || idx < 0) return '';
    const cells = Array.from(tr.children);
    const cell = cells[idx];
    if(!cell) return '';
    return sanitizeText(cell.textContent || '');
  }

  function isModZeroRow(tr, modIdx){
    // MOD 列の値が 0（"0" / "0.0" / "0%" 等）なら true
    if(modIdx < 0) return false;
    const t = getRowCellTextByIndex(tr, modIdx);
    if(!t) return false;
    // 0, 0.0, 0.00, 0%, 0.0% などを 0 扱い
    const m = t.match(/-?\d+(?:\.\d+)?/);
    if(!m) return false;
    const v = Number(m[0]);
    if(!Number.isFinite(v)) return false;
    return Math.abs(v) === 0;
  }

  async function openPickItemModal(kind){
    buildPickItemModal();
    const dlg = document.getElementById('dba-m-pick-item');
    const title = document.getElementById('dba-pick-title');
    const hint = document.getElementById('dba-pick-hint');
    const box = document.getElementById('dba-pick-box');
    const ok = document.getElementById('dba-pick-ok');
    const cancel = document.getElementById('dba-pick-cancel');
    if(!dlg || !box || !ok || !cancel) throw new Error('pick modal missing');

    const kLabel = (kind === 'weapon') ? '武器' : (kind === 'armor') ? '防具' : 'ネックレス';
    if(title) title.textContent = `${kLabel}を選択`;
    if(hint) hint.textContent = '行をクリックして選択してください（装/解/分解列は非表示）。';
    box.textContent = '読み込み中…';

    let selectedRow = null;
    let activeRarity = 'ALL';
    let hideModZero = false;
    let modColIdx = -1;

    // 表を取得して表示
    const doc = await fetchBagTableDoc();
    const tableId = pickTableIdByKind(kind);
    const srcTable = doc.getElementById(tableId);
    if(!srcTable){
      box.textContent = 'テーブルが見つかりませんでした。';
    }else{
      const imported = document.importNode(srcTable, true);

      // 装/解/分解列を非表示（列は残して ID 抽出に使う）
      hideColumnsByHeaderText(imported, ['装','解','分解']);

      // MOD 列 index（無ければ -1）
      modColIdx = getHeaderIndexByText(imported, 'MOD');

      // フィルタ適用（レアリティ + MOD0）
      const applyPickFilters = () => {
        const trs = Array.from(imported.querySelectorAll('tbody tr'));
        for(const tr of trs){
          const r = detectRarityFromRow(tr);
          const okRarity = (activeRarity === 'ALL') ? true : (r === activeRarity);
          const okMod = (!hideModZero) ? true : (!isModZeroRow(tr, modColIdx));
          const show = okRarity && okMod;
          tr.style.display = show ? '' : 'none';
        }
        // 選択行が非表示になったら選択解除
        if(selectedRow && selectedRow.style && selectedRow.style.display === 'none'){
          try{
            selectedRow.classList.remove('dba-pick-row-selected');
            for(const td of Array.from(selectedRow.querySelectorAll('td,th'))){
              td.classList.remove('dba-pick-row-selected');
            }
          }catch(_e2){}
          selectedRow = null;
        }
      };

      // レアリティフィルタUI（テーブルの上に設置）
      // - box の先頭にバーを挿入し、以降にテーブルを置く
      const filterBar = document.createElement('div');
      filterBar.className = 'dba-pick-filterbar';
      filterBar.id = 'dba-pick-filterbar';

      const mkBtn = (label, rar, cls) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = `dba-pick-filterbtn ${cls || ''}`.trim();
        b.textContent = label;
        b.dataset.rarity = rar;
        b.dataset.active = (rar === 'ALL') ? '1' : '0';
        b.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          activeRarity = rar;
          // active 表示
          for(const x of Array.from(filterBar.querySelectorAll('.dba-pick-filterbtn'))){
            x.dataset.active = (x.dataset.rarity === rar) ? '1' : '0';
          }
          applyPickFilters();
        });
        return b;
      };

      filterBar.appendChild(mkBtn('ALL', 'ALL', 'dba-pick-filterbtn--all'));
      filterBar.appendChild(mkBtn('N',   'N',   'dba-pick-filterbtn--n'));
      filterBar.appendChild(mkBtn('R',   'R',   'dba-pick-filterbtn--r'));
      filterBar.appendChild(mkBtn('SR',  'SR',  'dba-pick-filterbtn--sr'));
      filterBar.appendChild(mkBtn('SSR', 'SSR', 'dba-pick-filterbtn--ssr'));
      filterBar.appendChild(mkBtn('UR',  'UR',  'dba-pick-filterbtn--ur'));

      // チェックボックス：MOD 0 は表示しない
      const chkWrap = document.createElement('label');
      chkWrap.className = 'dba-pick-filterchk';
      chkWrap.id = 'dba-pick-chk-mod0-wrap';

      const chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.id = 'dba-pick-chk-mod0';

      const chkText = document.createElement('span');
      chkText.textContent = 'MOD 0 は表示しない';

      chkWrap.appendChild(chk);
      chkWrap.appendChild(chkText);
      filterBar.appendChild(chkWrap);

      // MOD列が無いテーブルでは無効化（例：ネックレス等のケース）
      if(modColIdx < 0){
        chk.disabled = true;
        chkWrap.dataset.disabled = '1';
      }else{
        chkWrap.dataset.disabled = '0';
        chk.addEventListener('change', (e) => {
          e.stopPropagation();
          hideModZero = !!chk.checked;
          applyPickFilters();
        });
      }

      // 選択ハンドラ
      for(const tr of Array.from(imported.querySelectorAll('tbody tr'))){
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // 以前の選択を解除（tr と td の両方）
          if(selectedRow){
            try{
              selectedRow.classList.remove('dba-pick-row-selected');
              for(const td of Array.from(selectedRow.querySelectorAll('td,th'))){
                td.classList.remove('dba-pick-row-selected');
              }
            }catch(_e2){}
          }

          selectedRow = tr;

          // 新しい選択に “赤フィルタ” を適用（tr と td の両方）
          try{
            selectedRow.classList.add('dba-pick-row-selected');
            for(const td of Array.from(selectedRow.querySelectorAll('td,th'))){
              td.classList.add('dba-pick-row-selected');
            }
          }catch(_e2){}
        });
      }

      box.textContent = '';
      // 先にフィルタバー、その下にテーブル
      box.appendChild(filterBar);
      box.appendChild(imported);

      // 初期状態でフィルタ適用（念のため）
      applyPickFilters();
    }

    // promise で OK/CANCEL を待つ
    return await new Promise((resolve, reject) => {
      function cleanup(){
        ok.onclick = null;
        cancel.onclick = null;
      }
      function closeDirect(){ try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); } }

      ok.onclick = (e) => {
        e.preventDefault(); e.stopPropagation();
        if(!selectedRow){
          // 未選択は null を返す（要件：未選択は null で埋める）
          cleanup();
          closeDirect();
          resolve({ id: null, label: `未選択（${kLabel}）` });
          return;
        }
        // 念のため、非表示行は選択不可扱い（フィルタで隠れている時）
        if(selectedRow.style && selectedRow.style.display === 'none'){
          cleanup();
          closeDirect();
          resolve({ id: null, label: `未選択（${kLabel}）` });
          return;
        }
        const id = extractEquipIdFromRow(selectedRow);
        const label = extractRowLabel(selectedRow, kind);
        cleanup();
        closeDirect();
        resolve({ id: (id == null ? null : Number(id)), label });
      };
      cancel.onclick = (e) => {
        e.preventDefault(); e.stopPropagation();
        cleanup();
        closeDirect();
        reject(new Error('cancel'));
      };

      try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
    });
  }

  const DBA_BATTLEINFO_LOG_PREFIX = '[DBA][BattleInfo]';
  // ============================================================
  // ▽ここから▽ Debug スイッチ（機能ごとにON/OFF）
  //  - デフォルトは全て OFF
  //  - 将来的に問題切り分けが必要になったら、該当フラグだけ true にする
  // ============================================================
  const DBA_DEBUG = {
    battleInfo: false, // 戦況情報 fetch/parse 周り
    battlemapRefresh: false, // 戦況情報の前にトップページからバトルマップのみ差し替え
    layerSync:  false, // 透明レイヤー追従（必要になったら追加でログ出し）
    rbPointer:  false  // RBの座標計算（必要になったら追加でログ出し）
  };
  // ============================================================
  // △ここまで△ Debug スイッチ（機能ごとにON/OFF）
  // ============================================================

  function dbgLog(flagKey, level, msg, obj){
    if(!DBA_DEBUG || !DBA_DEBUG[flagKey]) return;
    const fn = (level === 'warn') ? console.warn
              : (level === 'error') ? console.error
              : (level === 'info') ? console.info
              : console.log;
    try{
      fn(`${DBA_BATTLEINFO_LOG_PREFIX} ${msg}`, obj || {});
    }catch(_e){
      // noop
    }
  }

  // =========================
  // バトルマップ差し替え（トップページから取得→マップ部分だけ再構成）
  //  - 目的：スクロールや更新時のちらつきを抑えつつ、最新マップへ更新してから詳細取得へ進む
  //  - 注意：DOMParser由来の <script> は inert（非実行）なので、差し替え後に再生成して実行する
  // =========================
  function findCurrentBattlemapRoot(){
    if(mode === 'rb'){
      return document.querySelector('.gridCanvasOuter') || document.getElementById('gridWrap');
    }
    return document.querySelector('.grid');
  }

  function findFetchedBattlemapRoot(doc){
    if(mode === 'rb'){
      return doc.querySelector('.gridCanvasOuter') || doc.getElementById('gridWrap');
    }
    return doc.querySelector('.grid');
  }

  function reactivateScriptsWithin(root){
    if(!root) return 0;
    const scripts = Array.from(root.querySelectorAll('script'));
    let count = 0;
    for(const old of scripts){
      const s = document.createElement('script');
      // type属性を維持（基本は未指定のIIFE想定）
      if(old.type) s.type = old.type;
      if(old.noModule) s.noModule = true;
      // src は本ページでは基本使われていない想定だが、一応コピー
      if(old.src){
        s.src = old.src;
      }else{
        s.textContent = old.textContent || '';
      }
      old.replaceWith(s);
      count++;
    }
    return count;
  }

  function validateBattlemapAfterRefresh(){
    try{
      if(mode === 'rb'){
        const wrap = document.getElementById('gridWrap');
        const base = document.getElementById('gridBase');
        const ovl  = document.getElementById('gridOverlay');
        const ok = !!(wrap && base && ovl);
        return { ok, detail: { hasGridWrap: !!wrap, hasGridBase: !!base, hasGridOverlay: !!ovl } };
      }
      const grid = document.querySelector('.grid');
      if(!grid) return { ok:false, detail:{ hasGrid:false, cellCount:0 } };
      const cellCount = grid.querySelectorAll('.cell').length;
      // 0 だと、差し替え後のIIFEが実行されていない可能性が高い
      const ok = cellCount > 0;
      return { ok, detail:{ hasGrid:true, cellCount } };
    }catch(e){
      return { ok:false, detail:{ error: String(e && e.message ? e.message : e) } };
    }
  }

  // =========================
  // バトルマップ差し替え（fetch済み doc を使って差し替え）
  //  - updateOnlyChangedCellsFromTopPage の (2-3) で、
  //    既に取得済みの最新HTML/Docを再利用して「最新版への差し替え（再描画）」を行うためのヘルパー
  // =========================
  async function refreshBattlemapFromFetchedDoc(doc, meta){
    const topUrl = meta?.topUrl || `https://donguri.5ch.net/teambattle?m=${mode}`;
    const t0 = performance.now();
    const sx = window.scrollX;
    const sy = window.scrollY;

    dbgLog('battlemapRefresh', 'info', 'REFRESH(pre-fetched) start', { mode, topUrl, scrollX: sx, scrollY: sy });

    const curRoot = findCurrentBattlemapRoot();
    if(!curRoot){
      dbgLog('battlemapRefresh', 'warn', 'REFRESH(pre-fetched) skipped: current battlemap root not found', { mode, topUrl });
      return false;
    }
    if(!doc){
      dbgLog('battlemapRefresh', 'warn', 'REFRESH(pre-fetched) skipped: doc is null', { mode, topUrl });
      return false;
    }

    try{
      const fetchedRoot = findFetchedBattlemapRoot(doc);
      if(!fetchedRoot){
        dbgLog('battlemapRefresh', 'warn', 'REFRESH(pre-fetched) failed: fetched battlemap root not found', { mode, topUrl });
        return false;
      }

      const parent = curRoot.parentNode;
      if(!parent){
        dbgLog('battlemapRefresh', 'warn', 'REFRESH(pre-fetched) failed: current root has no parent', { mode, topUrl });
        return false;
      }

      const imported = document.importNode(fetchedRoot, true);
      parent.replaceChild(imported, curRoot);

      const reactivated = reactivateScriptsWithin(imported);
      dbgLog('battlemapRefresh', 'info', 'REFRESH(pre-fetched) scripts reactivated', { mode, topUrl, scripts: reactivated });

      await raf2();
      window.scrollTo(sx, sy);

      applyCurrentModeScale();
      if(mode === 'rb') ensureRbPointerFix();
      scheduleBattlemapLayerSync();

      const v = validateBattlemapAfterRefresh();
      const dt = Math.round(performance.now() - t0);
      if(v.ok){
        dbgLog('battlemapRefresh', 'info', 'REFRESH(pre-fetched) success', { mode, topUrl, ms: dt, ...v.detail });
      }else{
        dbgLog('battlemapRefresh', 'warn', 'REFRESH(pre-fetched) failed: validation NG', { mode, topUrl, ms: dt, ...v.detail });
      }
      return v.ok;
    }catch(e){
      dbgLog('battlemapRefresh', 'error', 'REFRESH(pre-fetched) exception', { mode, topUrl, error: String(e && e.message ? e.message : e) });
      try{ window.scrollTo(sx, sy); }catch(_e){}
      return false;
    }
  }

  async function refreshBattlemapFromTopPage(){
    const topUrl = `https://donguri.5ch.net/teambattle?m=${mode}`;
    const t0 = performance.now();
    const sx = window.scrollX;
    const sy = window.scrollY;

    dbgLog('battlemapRefresh', 'info', 'REFRESH start', { mode, topUrl, scrollX: sx, scrollY: sy });

    const curRoot = findCurrentBattlemapRoot();
    if(!curRoot){
      dbgLog('battlemapRefresh', 'warn', 'REFRESH skipped: current battlemap root not found', { mode, topUrl });
      return false;
    }

    try{
      const res = await fetch(topUrl, { method:'GET', credentials:'include', cache:'no-store' });
      if(!res.ok){
        dbgLog('battlemapRefresh', 'warn', 'REFRESH fetch failed', { mode, topUrl, status: res.status, statusText: res.statusText });
        return false;
      }
      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const fetchedRoot = findFetchedBattlemapRoot(doc);
      if(!fetchedRoot){
        dbgLog('battlemapRefresh', 'warn', 'REFRESH failed: fetched battlemap root not found', { mode, topUrl, htmlLen: html?.length || 0 });
        return false;
      }

      // DOM差し替え（位置/スクロール維持）
      const parent = curRoot.parentNode;
      if(!parent){
        dbgLog('battlemapRefresh', 'warn', 'REFRESH failed: current root has no parent', { mode, topUrl });
        return false;
      }

      const imported = document.importNode(fetchedRoot, true);
      parent.replaceChild(imported, curRoot);

      // inert script を再生成して実行
      const reactivated = reactivateScriptsWithin(imported);
      dbgLog('battlemapRefresh', 'info', 'REFRESH scripts reactivated', { mode, topUrl, scripts: reactivated });

      // 2 raf 待機（スクリプトによるDOM反映・描画を待つ）
      await raf2();

      // スクロール維持（差し替えによる微妙なレイアウト変動でズレるのを戻す）
      window.scrollTo(sx, sy);

      // スケール・ポインタ補正・レイヤー追従を再適用
      applyCurrentModeScale();
      if(mode === 'rb') ensureRbPointerFix();
      scheduleBattlemapLayerSync();

      const v = validateBattlemapAfterRefresh();
      const dt = Math.round(performance.now() - t0);
      if(v.ok){
        dbgLog('battlemapRefresh', 'info', 'REFRESH success', { mode, topUrl, ms: dt, ...v.detail });
      }else{
        dbgLog('battlemapRefresh', 'warn', 'REFRESH failed: validation NG', { mode, topUrl, ms: dt, ...v.detail });
      }
      return v.ok;
    }catch(e){
      dbgLog('battlemapRefresh', 'error', 'REFRESH exception', { mode, topUrl, error: String(e && e.message ? e.message : e) });
      try{ window.scrollTo(sx, sy); }catch(_e){}
      return false;
    }
  }

  function textIncludesJP(s, keyword){
    return sanitizeText(s).includes(keyword);
  }

  function parseCellDetailHTML(htmlText, ctx){
    try{
      const doc = new DOMParser().parseFromString(htmlText, 'text/html');
      const tables = Array.from(doc.querySelectorAll('table'));
      dbgLog('battleInfo', 'info', 'PARSE start', {
        row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
        tables: tables.length,
        htmlLen: (htmlText && htmlText.length) ? htmlText.length : 0
      });

      if(tables.length === 0){
        dbgLog('battleInfo', 'warn', 'PARSE no table', { row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url });
        return { holder: '---', reg: '---' };
      }

      // 「ホルダー」ヘッダーを持つ table を優先して探す（モード差・余計なtable混在対策）
      let targetTable = null;
      for(const t of tables){
        const ths = Array.from(t.querySelectorAll('tr th')).map(th => sanitizeText(th.textContent));
        if(ths.some(x => x.includes('ホルダー'))){
          targetTable = t;
          break;
        }
      }
      if(!targetTable) targetTable = tables[0];

      // ヘッダー行（th を含む tr）を特定
      const headerTr = targetTable.querySelector('tr:has(th)') || targetTable.querySelector('tr');
      const thList = headerTr ? Array.from(headerTr.querySelectorAll('th')).map(th => sanitizeText(th.textContent)) : [];
      let holderIdx = -1;
      for(let i=0;i<thList.length;i++){
        if(thList[i].includes('ホルダー')){
          holderIdx = i;
          break;
        }
      }

      dbgLog('info', 'PARSE table selected', {
        row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
        ths: thList,
        holderIdx
      });
      dbgLog('battleInfo', 'info', 'PARSE table selected', {
        row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
        ths: thList,
        holderIdx
      });

      // データ行を取得（th行を避けて最初のtd行）
      const trs = Array.from(targetTable.querySelectorAll('tr'));
      let dataTr = null;
      for(const tr of trs){
        if(tr.querySelector('td')){
          dataTr = tr;
          break;
        }
      }
      if(!dataTr){
        dbgLog('battleInfo', 'warn', 'PARSE no data tr', {
          row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
          trCount: trs.length
        });
        return { holder: '---', reg: '---' };
      }

      const tds = Array.from(dataTr.querySelectorAll('td'));
      dbgLog('battleInfo', 'info', 'PARSE data row', {
        row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
        tdCount: tds.length
      });

      // holderIdx が取れない/範囲外のときは、従来通り “2列目” をフォールバック
      const idx = (holderIdx >= 0 && holderIdx < tds.length) ? holderIdx : 1;
      const tdHolder = (tds.length > idx) ? tds[idx] : null;
      if(!tdHolder){
        dbgLog('battleInfo', 'warn', 'PARSE no holder td', {
          row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
          idx
        });
        return { holder: '---', reg: '---' };
      }

      // 抽出（strong/small 優先、無ければテキストから推測）
      const holderEl = tdHolder.querySelector('strong');
      const regEl = tdHolder.querySelector('small');

      const tdTextRaw = sanitizeText(tdHolder.textContent);
      let holder = sanitizeText(holderEl ? holderEl.textContent : '');
      let reg = sanitizeText(regEl ? regEl.textContent : '');

      if(!holder){
        // 「エリアに挑む」等のボタン文言以降は捨てる
        holder = tdTextRaw
          .replace(/エリアに挑む.*$/,'')
          .replace(/エリアに挑戦.*$/,'')
          .trim();
      }
      if(!reg){
        // [N]から[SR]まで / [SSR]まで 等をテキストから拾う
        const m = tdTextRaw.match(/\[[^\]]+\](?:から\[[^\]]+\])?まで/);
        reg = sanitizeText(m ? m[0] : '');
      }

      dbgLog('battleInfo', 'info', 'PARSE extracted', {
        row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
        holder, reg,
        tdTextSample: tdTextRaw.slice(0, 140)
      });

      const out = { holder: holder || '---', reg: reg || '---' };
      if(out.holder === '---' && out.reg === '---'){
        // 失敗時だけ、HTML先頭を少し出す（巨大ログ回避）
        dbgLog('battleInfo', 'warn', 'PARSE result is ---/---', {
          row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
          htmlHead: String(htmlText || '').slice(0, 400)
        });
      }
      return out;
    }catch(_e){
      dbgLog('battleInfo', 'error', 'PARSE exception', {
        row: ctx?.row, col: ctx?.col, mode: ctx?.mode, url: ctx?.url,
        error: String(_e && _e.message ? _e.message : _e)
      });
      return { holder: '---', reg: '---' };
    }
  }

  async function fetchCellDetail(row, col){
    const url = `https://donguri.5ch.net/teambattle?r=${row}&c=${col}&m=${mode}`;
    try{
      const res = await fetch(url, {
        method: 'GET',
        credentials: 'include',
        cache: 'no-store'
      });
      if(!res.ok){
        dbgLog('battleInfo', 'warn', 'FAIL fetch', { row, col, mode, status: res.status, statusText: res.statusText, url });
        throw new Error(`HTTP ${res.status}`);
      }
      dbgLog('battleInfo', 'info', 'OK fetch', { row, col, mode, status: res.status, url });
      const html = await res.text();
      const parsed = parseCellDetailHTML(html, { row, col, mode, url });
      if(parsed && parsed.holder === '---' && parsed.reg === '---'){
        dbgLog('battleInfo', 'warn', 'FETCH ok but PARSE returned ---/---', { row, col, mode, url });
      }
      return parsed;
    }catch(e){
      dbgLog('battleInfo', 'warn', 'FAIL fetch (exception)', { row, col, mode, url, error: String(e && e.message ? e.message : e) });
      throw e;
    }
  }

  async function mapLimit(items, limit, mapper){
    const results = new Array(items.length);
    let i = 0;
    let active = 0;
    return await new Promise((resolve) => {
      const next = () => {
        while(active < limit && i < items.length){
          const idx = i++;
          active++;
          Promise.resolve()
            .then(() => mapper(items[idx], idx))
            .then((val) => { results[idx] = val; })
            .catch((err) => { results[idx] = { error: err }; })
            .finally(() => {
              active--;
              if(i >= items.length && active === 0) resolve(results);
              else next();
            });
        }
        if(items.length === 0) resolve([]);
      };
      next();
    });
  }

  function setLayerCellText(row, col, text){
    const cell = document.querySelector(`#dba-battlemap-layer-grid .dba-layer-cell[data-row="${row}"][data-col="${col}"] .dba-layer-cell__content`);
    if(cell) cell.textContent = text;
  }

  function clearLayerTexts(){
    for(const el of document.querySelectorAll('#dba-battlemap-layer-grid .dba-layer-cell__content')){
      el.textContent = '';
    }
  }

  async function scanAllCellsAndRender(){
    const btn = document.getElementById('dba-btn-battleinfo');
    if(btn){
      btn.disabled = true;
      btn.dataset.dbaBusy = '1';
      btn.textContent = 'マップ更新中…';
    }

    // 先にトップページからバトルマップだけ更新（スクロール/ちらつき抑制）
    // 失敗しても戦況取得自体は続行（ただし debug ON 時に成否ログが出る）
    const refreshed = await refreshBattlemapFromTopPage();
    if(btn){
      btn.textContent = refreshed ? '戦況取得中…' : '戦況取得中…(マップ更新失敗)';
    }

    // レイヤーが未生成なら生成＆同期（マップ更新後にやる：セル数変動に追従させる）
    initBattlemapLayer();
    scheduleBattlemapLayerSync();
    await raf2(); // cells が rebuild されるのを待つ

    // まず全セルにプレースホルダ
    clearLayerTexts();
    const cells = Array.from(document.querySelectorAll('#dba-battlemap-layer-grid .dba-layer-cell'));
    for(const c of cells){
      setLayerCellText(c.dataset.row, c.dataset.col, '…');
    }

    // fetch の並列数（多すぎると重いので抑制）
    const CONCURRENCY = 9;

    const jobs = cells.map((c) => ({ row: Number(c.dataset.row), col: Number(c.dataset.col) }));
    await mapLimit(jobs, CONCURRENCY, async (job) => {
      const { row, col } = job;
      try{
        const { holder, reg } = await fetchCellDetail(row, col);
        // 表示：レギュレーション + ホルダー
        setLayerCellText(row, col, `${reg}\n${holder}`);
      }catch(_e){
        setLayerCellText(row, col, `ERR\n(${row},${col})`);
      }
      return true;
    });

    if(btn){
      btn.disabled = false;
      btn.dataset.dbaBusy = '0';
      btn.textContent = '戦況情報';
    }
  }

  // =========================
  // 戦況情報（クリック：差分だけ更新）
  //  - 長押し：全セル巡回（scanAllCellsAndRender）
  //  - クリック：最新マップの const 群を取得し、差分セルだけ詳細ページを取りにいってレイヤー表示を更新
  // =========================
  function parseJsValueLiteral(lit){
    // 同一オリジンのページ内スクリプトから抽出する前提（安全性より堅牢性を優先）
    // eslint-disable-next-line no-new-func
    return Function('"use strict"; return (' + lit + ');')();
  }

  function pickScriptText(doc, mustInclude){
    const scripts = Array.from(doc.querySelectorAll('script'));
    for(const sc of scripts){
      const t = sc.textContent || '';
      if(!t) continue;
      let ok = true;
      for(const kw of mustInclude){
        if(!t.includes(kw)){ ok = false; break; }
      }
      if(ok) return t;
    }
    return '';
  }

  function extractConstLiteral(scriptText, constName){
    // 例: const cellColors = { ... };
    const re1 = new RegExp(`const\\s+${constName}\\s*=\\s*([\\s\\S]*?);\\s*(?:\\n|$)`);
    const m = scriptText.match(re1);
    if(!m) return null;
    return (m[1] || '').trim();
  }

  function normalizeCellColors(obj){
    const out = Object.create(null);
    if(!obj || typeof obj !== 'object') return out;
    for(const [k,v] of Object.entries(obj)){
      const key = String(k).trim();
      if(!key) continue;
      out[key] = (v == null) ? null : String(v).trim();
    }
    return out;
  }

  function normalizeCapitalSet(list){
    const set = new Set();
    if(!Array.isArray(list)) return set;
    for(const rc of list){
      if(!Array.isArray(rc) || rc.length < 2) continue;
      const r = Number(rc[0]);
      const c = Number(rc[1]);
      if(!Number.isFinite(r) || !Number.isFinite(c)) continue;
      set.add(`${r}-${c}`);
    }
    return set;
  }

  function normalizeTerrainsPayload(payload){
    // RB専用：terrainsPayload.terrains の中身だけを正規化して比較
    try{
      const arr = payload && payload.terrains;
      if(!Array.isArray(arr)) return '';
      const rows = [];
      for(const cell of arr){
        if(!cell) continue;
        const r = Number(cell.r ?? cell.row ?? cell.x);
        const c = Number(cell.c ?? cell.col ?? cell.y);
        const t = String(cell.t ?? cell.terrain ?? '').trim();
        if(!Number.isFinite(r) || !Number.isFinite(c)) continue;
        rows.push({ r, c, t });
      }
      rows.sort((a,b) => (a.r - b.r) || (a.c - b.c) || (a.t < b.t ? -1 : (a.t > b.t ? 1 : 0)));
      return JSON.stringify(rows);
    }catch(_e){
      return '';
    }
  }

  function getHcLGridSpecFromDoc(doc){
    const grid = doc.querySelector('.grid');
    if(!grid) return { rows:0, cols:0 };
    // fetched doc では computedStyle が使えないことがあるので style から読む
    const style = grid.getAttribute('style') || '';
    const m1 = style.match(/grid-template-columns:\s*repeat\(\s*(\d+)\s*,/);
    const m2 = style.match(/grid-template-rows:\s*repeat\(\s*(\d+)\s*,/);
    const cols = m1 ? Number(m1[1]) : 0;
    const rows = m2 ? Number(m2[1]) : 0;
    return { rows, cols };
  }

  function getCurrentHcLGridSize(){
    const grid = document.querySelector('.grid');
    if(!grid) return { rows:0, cols:0 };
    const spec = getHcLGridSpec(grid);
    return { rows: spec.rows, cols: spec.cols };
  }

  function getBattlemapSnapshotFromDoc(doc){
    const out = {
      mode,
      rows: 0,
      cols: 0,
      cellColors: Object.create(null),
      capitalSet: new Set(),
      terrainsKey: '' // RBのみ
    };

    if(mode === 'rb'){
      const t = pickScriptText(doc, ['const GRID_SIZE', 'const cellColors', 'terrainsPayload']);
      const litSize = extractConstLiteral(t, 'GRID_SIZE');
      const litColors = extractConstLiteral(t, 'cellColors');
      const litCap = extractConstLiteral(t, 'capitalList') || extractConstLiteral(t, 'capitalMap');
      const litTerr = extractConstLiteral(t, 'terrainsPayload');

      let size = 0;
      try{ size = Number(parseJsValueLiteral(litSize)); }catch(_e){ size = 0; }
      if(!Number.isFinite(size) || size <= 0) size = 16;
      out.rows = size;
      out.cols = size;

      try{ out.cellColors = normalizeCellColors(parseJsValueLiteral(litColors)); }catch(_e){ out.cellColors = Object.create(null); }
      try{ out.capitalSet = normalizeCapitalSet(parseJsValueLiteral(litCap)); }catch(_e){ out.capitalSet = new Set(); }
      try{ out.terrainsKey = normalizeTerrainsPayload(parseJsValueLiteral(litTerr)); }catch(_e){ out.terrainsKey = ''; }
      return out;
    }

    // hc / l
    const t = pickScriptText(doc, ['const cellColors', 'const capitalMap', 'createGrid']);
    const litColors = extractConstLiteral(t, 'cellColors');
    const litCap = extractConstLiteral(t, 'capitalMap') || extractConstLiteral(t, 'capitalList');

    if(doc === document){
      const sz = getCurrentHcLGridSize();
      out.rows = sz.rows;
      out.cols = sz.cols;
    }else{
      const sz = getHcLGridSpecFromDoc(doc);
      out.rows = sz.rows;
      out.cols = sz.cols;
    }

    try{ out.cellColors = normalizeCellColors(parseJsValueLiteral(litColors)); }catch(_e){ out.cellColors = Object.create(null); }
    try{ out.capitalSet = normalizeCapitalSet(parseJsValueLiteral(litCap)); }catch(_e){ out.capitalSet = new Set(); }
    return out;
  }

  function diffChangedCells(curSnap, newSnap){
    const changed = [];
    const keys = new Set();

    // 全セルキー（サイズ範囲）を対象にする：色/首都の変化検出を漏らさない
    for(let r=0;r<curSnap.rows;r++){
      for(let c=0;c<curSnap.cols;c++){
        keys.add(`${r}-${c}`);
      }
    }
    for(let r=0;r<newSnap.rows;r++){
      for(let c=0;c<newSnap.cols;c++){
        keys.add(`${r}-${c}`);
      }
    }
    // cellColors にだけ存在するキーも対象（念のため）
    for(const k of Object.keys(curSnap.cellColors||{})) keys.add(k);
    for(const k of Object.keys(newSnap.cellColors||{})) keys.add(k);

    for(const k of keys){
      const c1 = (curSnap.cellColors && (k in curSnap.cellColors)) ? curSnap.cellColors[k] : null;
      const c2 = (newSnap.cellColors && (k in newSnap.cellColors)) ? newSnap.cellColors[k] : null;
      const cap1 = curSnap.capitalSet ? curSnap.capitalSet.has(k) : false;
      const cap2 = newSnap.capitalSet ? newSnap.capitalSet.has(k) : false;
      if(c1 !== c2 || cap1 !== cap2){
        const m = k.match(/^(\d+)-(\d+)$/);
        if(!m) continue;
        changed.push({ row: Number(m[1]), col: Number(m[2]) });
      }
    }
    // 走査順を安定化
    changed.sort((a,b) => (a.row - b.row) || (a.col - b.col));
    return changed;
  }

  async function updateOnlyChangedCellsFromTopPage(){
    const btn = document.getElementById('dba-btn-battleinfo');
    if(btn){
      btn.disabled = true;
      btn.dataset.dbaBusy = '1';
      btn.textContent = '差分確認中…';
    }

    const topUrl = `https://donguri.5ch.net/teambattle?m=${mode}`;
    try{
      // (1) 最新ページを取得
      const res = await fetch(topUrl, { method:'GET', credentials:'include', cache:'no-store' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');

      // (2) 現在と最新を比較
      const curSnap = getBattlemapSnapshotFromDoc(document);
      const newSnap = getBattlemapSnapshotFromDoc(doc);

      // (2-1) サイズ違い → 長押しと同じ
      if(curSnap.rows !== newSnap.rows || curSnap.cols !== newSnap.cols){
        if(btn) btn.textContent = '全更新（サイズ差）…';
        await scanAllCellsAndRender();
        return;
      }

      // (2-2) RBのみ terrainsPayload が違う → 長押しと同じ
      if(mode === 'rb'){
        if((curSnap.terrainsKey || '') !== (newSnap.terrainsKey || '')){
          if(btn) btn.textContent = '全更新（地形差）…';
          await scanAllCellsAndRender();
          return;
        }
      }

      // (2-3) 差分セルだけ詳細取得
      const changed = diffChangedCells(curSnap, newSnap);

      // ★追加要件： (2-3) に該当する場合は、差分セルの詳細取得に加えて
      // 「バトルマップの最新版への差し替え（最新データを使っての再描画）」も実施する
      // - ここでは既に取得済みの doc を再利用し、余計な再fetchを避ける
      // - 差分が0の時は差し替え不要（軽量化）
      if(changed.length > 0){
        if(btn) btn.textContent = 'マップ差し替え中…';
        const refreshed = await refreshBattlemapFromFetchedDoc(doc, { topUrl });
        if(btn){
          btn.textContent = refreshed
            ? `差分更新中…(${changed.length})`
            : `差分更新中…(${changed.length}) (マップ更新失敗)`;
        }
      }

      // レイヤーが未生成なら生成＆同期
      initBattlemapLayer();
      scheduleBattlemapLayerSync();
      await raf2();

      if(changed.length === 0){
        if(btn){
          btn.textContent = '差分なし';
          setTimeout(() => {
            btn.disabled = false;
            btn.dataset.dbaBusy = '0';
            btn.textContent = '戦況情報';
          }, 600);
        }
        return;
      }

      // 上でマップ差し替えが走った場合も、ここで改めて表示を揃える
      if(btn && btn.textContent.indexOf('差分更新中…') !== 0)
        btn.textContent = `差分更新中…(${changed.length})`;

      const CONCURRENCY = 9;
      await mapLimit(changed, CONCURRENCY, async (job, idx) => {
        const { row, col } = job;
        try{
          const { holder, reg } = await fetchCellDetail(row, col);
          setLayerCellText(row, col, `${reg}\n${holder}`);
        }catch(_e){
          setLayerCellText(row, col, `ERR\n(${row},${col})`);
        }
        if(btn && (idx % 10 === 0)){
          const done = idx + 1;
          btn.textContent = `差分更新中…(${done}/${changed.length})`;
        }
        return true;
      });

      if(btn){
        btn.disabled = false;
        btn.dataset.dbaBusy = '0';
        btn.textContent = '戦況情報';
      }
    }catch(e){
      dbgLog('battleInfo', 'warn', 'CLICK update failed', { mode, error: String(e && e.message ? e.message : e) });
      if(btn){
        btn.disabled = false;
        btn.dataset.dbaBusy = '0';
        btn.textContent = '戦況情報';
      }
      alert('戦況情報の取得に失敗しました。');
    }
  }

  function waitAndApplyScale(){
    const tryApply = () => {
      if(mode === 'rb'){
        if(applyScaleToCanvasWrap(loadSettings().scale.rb)){
          ensureRbPointerFix();
          scheduleBattlemapLayerSync();
          return true;
        }
      }else{
        if(applyScaleToGrid(loadSettings().scale[mode])){
          scheduleBattlemapLayerSync();
          return true;
        }
      }
      return false;
    };

    if(tryApply()) return;

    const mo = new MutationObserver(() => {
      if(tryApply()){
        mo.disconnect();
      }
    });
    mo.observe(document.documentElement, { childList: true, subtree: true });
  }

  // =========================
  // 設定モーダル（UI）
  // =========================
  function buildSettingsModal(){
    if(document.getElementById('dba-m-settings')) return;

    const dlg = document.createElement('dialog');
    dlg.id = 'dba-m-settings';
    dlg.className = 'dba-m-std';

    // Top
    const top = document.createElement('div');
    top.className = 'dba-modal__top';

    const title = document.createElement('div');
    title.className = 'dba-modal__title';
    title.textContent = '設定';

    const btnX = document.createElement('button');
    btnX.type = 'button';
    btnX.className = 'dba-btn-x';
    btnX.textContent = '×';

    top.appendChild(title);
    top.appendChild(btnX);

    // Mid
    const mid = document.createElement('div');
    mid.className = 'dba-modal__mid';

    const hint = document.createElement('div');
    hint.style.textAlign = 'left';
    hint.style.marginBottom = '10px';
    hint.style.fontSize = '0.95em';
    hint.textContent = '各モードのバトルマップのセルサイズ（%）を設定できます（100〜200、範囲外は100に補正）。';
    mid.appendChild(hint);

    const settings = loadSettings();

    function mkRow(modeKey){
      const row = document.createElement('div');
      row.className = 'dba-setting-row';

      const lab = document.createElement('label');
      lab.textContent = getModeLabel(modeKey);

      const input = document.createElement('input');
      input.type = 'number';
      input.min = '100';
      input.max = '200';
      input.step = '1';
      input.value = String(sanitizeScale(settings.scale[modeKey]));
      input.dataset.modeKey = modeKey;

      row.appendChild(lab);
      row.appendChild(input);
      return row;
    }

    mid.appendChild(mkRow('rb'));
    mid.appendChild(mkRow('hc'));
    mid.appendChild(mkRow('l'));

    // レイヤー文字濃度（将来のテキスト/絵文字表示のための事前準備）
    (function mkOpacityRow(){
      const row = document.createElement('div');
      row.className = 'dba-setting-row';

      const lab = document.createElement('label');
      lab.textContent = 'レイヤー文字濃度（0〜100）';

      const wrap = document.createElement('div');
      wrap.style.display = 'grid';
      wrap.style.gridTemplateColumns = '1fr 52px';
      wrap.style.gap = '8px';
      wrap.style.alignItems = 'center';

      const input = document.createElement('input');
      input.type = 'range';
      input.min = '0';
      input.max = '100';
      input.step = '1';
      input.value = String(sanitizeOpacity(settings.layer.textOpacity));
      input.dataset.layerOpacity = '1';

      const out = document.createElement('div');
      out.textContent = input.value;
      out.style.textAlign = 'right';
      out.style.fontWeight = '700';

      input.addEventListener('input', () => {
        out.textContent = input.value;
        // 即時反映（保存は Apply/OK）
        applyLayerTextOpacity(input.value);
      }, { passive: true });

      wrap.appendChild(input);
      wrap.appendChild(out);

      row.appendChild(lab);
      row.appendChild(wrap);
      mid.appendChild(row);
    })();

    // Bot
    const bot = document.createElement('div');
    bot.className = 'dba-modal__bot';

    const btnOK = document.createElement('button');
    btnOK.type = 'button';
    btnOK.className = 'dba-btn-ok';
    btnOK.textContent = 'OK';

    const btnApply = document.createElement('button');
    btnApply.type = 'button';
    btnApply.className = 'dba-btn-apply';
    btnApply.textContent = 'Apply';

    const btnClose = document.createElement('button');
    btnClose.type = 'button';
    btnClose.className = 'dba-btn-close';
    btnClose.textContent = 'Close';

    bot.appendChild(btnOK);
    bot.appendChild(btnApply);
    bot.appendChild(btnClose);

    dlg.appendChild(top);
    dlg.appendChild(mid);
    dlg.appendChild(bot);

    document.body.appendChild(dlg);

    // Alert modal
    const adlg = document.createElement('dialog');
    adlg.id = 'dba-m-alert';
    adlg.className = 'dba-m-alert';

    const amid = document.createElement('div');
    amid.className = 'dba-alert__mid';
    amid.textContent = '変更を保存せずに閉じますか？';

    const abot = document.createElement('div');
    abot.className = 'dba-alert__bot';

    const aYes = document.createElement('button');
    aYes.type = 'button';
    aYes.className = 'dba-btn-ok';
    aYes.textContent = 'はい';

    const aBack = document.createElement('button');
    aBack.type = 'button';
    aBack.className = 'dba-btn-close';
    aBack.textContent = '戻る';

    abot.appendChild(aYes);
    abot.appendChild(aBack);

    adlg.appendChild(amid);
    adlg.appendChild(abot);
    document.body.appendChild(adlg);

    // dirty tracking
    let initial = JSON.stringify(readModalValues());
    let dirty = false;

    function readModalValues(){
      const out = { rb: 100, hc: 100, l: 100, layerTextOpacity: 100 };
      for(const inp of dlg.querySelectorAll('input[type="number"][data-mode-key]')){
        const k = inp.dataset.modeKey;
        out[k] = Number.parseInt(inp.value, 10);
      }
      const op = dlg.querySelector('input[type="range"][data-layer-opacity="1"]');
      if(op) out.layerTextOpacity = Number.parseInt(op.value, 10);
      return out;
    }

    function setInputsFromSettings(s){
      for(const inp of dlg.querySelectorAll('input[type="number"][data-mode-key]')){
        const k = inp.dataset.modeKey;
        inp.value = String(sanitizeScale(s.scale[k]));
      }
      const op = dlg.querySelector('input[type="range"][data-layer-opacity="1"]');
      if(op){
        op.value = String(sanitizeOpacity(s.layer.textOpacity));
        // 表示側の数値も更新
        const disp = op.parentElement && op.parentElement.children ? op.parentElement.children[1] : null;
        if(disp && disp.textContent != null) disp.textContent = op.value;
      }
    }

    function refreshInitial(){
      initial = JSON.stringify(readModalValues());
      dirty = false;
    }

    function isDirty(){
      return JSON.stringify(readModalValues()) !== initial;
    }

    function commitFromModal(){
      const cur = loadSettings();
      const v = readModalValues();
      cur.scale.rb = sanitizeScale(v.rb);
      cur.scale.hc = sanitizeScale(v.hc);
      cur.scale.l  = sanitizeScale(v.l);
      cur.layer.textOpacity = sanitizeOpacity(v.layerTextOpacity);

      // 範囲外入力はここで 100 に補正し、UIにも反映
      saveSettings(cur);
      setInputsFromSettings(cur);

      // 反映
      applyCurrentModeScale();
      scheduleBattlemapLayerSync();

      refreshInitial();
    }

    function closeDirect(){
      try{ dlg.close(); }catch(_e){ dlg.removeAttribute('open'); }
    }

    function askCloseIfDirty(){
      if(!isDirty()){
        closeDirect();
        return;
      }
      try{ adlg.showModal(); }catch(_e){ adlg.setAttribute('open',''); }
    }

    // input change -> mark dirty
    dlg.addEventListener('input', () => { dirty = true; }, true);

    // Buttons
    btnApply.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      commitFromModal();
    });

    btnOK.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      commitFromModal();
      closeDirect();
    });

    btnClose.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      askCloseIfDirty();
    });

    btnX.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      askCloseIfDirty();
    });

    // Alert buttons
    aYes.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      // 破棄して閉じる：設定値は保存しない、UIも復元
      setInputsFromSettings(loadSettings());
      refreshInitial();
      try{ adlg.close(); }catch(_e){ adlg.removeAttribute('open'); }
      closeDirect();
    });

    aBack.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      try{ adlg.close(); }catch(_e){ adlg.removeAttribute('open'); }
      // 元の設定モーダルに戻る（既に開いている）
      try{
        // noop
      }catch(_e){}
    });

    // ESC で閉じる時も同じ挙動にする（ダイアログの cancel を抑止）
    dlg.addEventListener('cancel', (e) => {
      e.preventDefault();
      askCloseIfDirty();
    });

    // アラート側 ESC は戻る扱い
    adlg.addEventListener('cancel', (e) => {
      e.preventDefault();
      try{ adlg.close(); }catch(_e){ adlg.removeAttribute('open'); }
    });
  }

  function openSettingsModal(){
    // body が無い可能性があるので待つ
    const openNow = () => {
      buildSettingsModal();
      const dlg = document.getElementById('dba-m-settings');
      if(!dlg) return;
      try{ dlg.showModal(); }catch(_e){ dlg.setAttribute('open',''); }
    };

    if(document.body) openNow();
    else document.addEventListener('DOMContentLoaded', openNow, { once: true });
  }

  function buildFunctionSection() {
    const bar = document.createElement('section');
    bar.id = 'dba-function-section';

    const btnSettings = document.createElement('button');
    btnSettings.type = 'button';
    btnSettings.className = 'dba-btn-fn';
    btnSettings.textContent = '設定';
    btnSettings.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      openSettingsModal();
    });

    const btnRoster = document.createElement('button');
    btnRoster.type = 'button';
    btnRoster.className = 'dba-btn-fn';
    btnRoster.textContent = '装備ロスター';
    btnRoster.id = 'dba-btn-roster';
    btnRoster.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      openRosterModal();
    });


    const btnBattleInfo = document.createElement('button');
    btnBattleInfo.type = 'button';
    btnBattleInfo.className = 'dba-btn-fn';
    btnBattleInfo.textContent = '戦況情報';
    btnBattleInfo.id = 'dba-btn-battleinfo';

    // 長押し（1.6秒）で全セル巡回してレイヤーに表示
    let lpTimer = 0;
    let lpFired = false;
    const LP_MS = 1600;

    function clearLP(){
      if(lpTimer){
        clearTimeout(lpTimer);
        lpTimer = 0;
      }
    }

    btnBattleInfo.addEventListener('pointerdown', (e) => {
      if(btnBattleInfo.disabled) return;
      e.preventDefault();
      e.stopPropagation();
      lpFired = false;
      clearLP();
      lpTimer = setTimeout(async () => {
        lpFired = true;
        try{
          await scanAllCellsAndRender();
        }catch(_e){
          // 何かあれば控えめに
          alert('戦況情報の取得に失敗しました。');
        }
      }, LP_MS);
    });
    btnBattleInfo.addEventListener('pointerup', clearLP);
    btnBattleInfo.addEventListener('pointercancel', clearLP);
    btnBattleInfo.addEventListener('pointerleave', clearLP);

    // 通常クリック（短押し）：差分更新（必要なセルだけ詳細ページを取りに行って更新）
    btnBattleInfo.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if(lpFired) return;
      if(btnBattleInfo.disabled) return;
      await updateOnlyChangedCellsFromTopPage();
    });

    bar.appendChild(btnSettings);
    bar.appendChild(btnRoster);
    bar.appendChild(btnBattleInfo);
    return bar;
  }

  function injectWhenReady() {
    addStyle(CSS);

    const doInsert = () => {
      // 二重挿入防止
      if (document.getElementById('dba-function-section')) return;

      document.documentElement.classList.add('dba-has-fnbar');

      const bar = buildFunctionSection();

      const header = document.querySelector('header');
      if (header && header.parentNode) {
        header.parentNode.insertBefore(bar, header);
      } else {
        // header が見つからない場合は body 先頭に
        (document.body || document.documentElement).insertBefore(bar, (document.body || document.documentElement).firstChild);
      }
      // バトルマップのセルスケール（保存値）を適用
      waitAndApplyScale();
      // 透明レイヤーを初期化（バトルマップ追従）
      initBattlemapLayer();
      // セルクリックで詳細モーダル（遷移抑止）
      initBattlemapCellClickIntercept();
    };

    // document-start なので body がまだ無いことがある：DOM 構築を待つ
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', doInsert, { once: true });
    } else {
      doInsert();
    }
  }

  injectWhenReady();
})();
